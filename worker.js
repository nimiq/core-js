class Class{static get scope(){return"undefined"!=typeof exports?exports:"undefined"!=typeof self?self:window}static register(e){"undefined"!=typeof exports&&(exports[e.name]=e)}}Class.register(Class);class LogNative{constructor(){this._global_level=Log.INFO,this._tag_levels={};try{if(window.localStorage)try{let e=window.localStorage.getItem("log_tag_levels");e&&"string"==typeof e&&(e=JSON.parse(e)),e&&"object"==typeof e&&(this._tag_levels=e)}catch(e){console.warn("Failed to load log configuration from local storage.")}}catch(e){}}isLoggable(e,t){return e&&this._tag_levels[e]?this._tag_levels[e]<=t:this._tag_levels["*"]?this._tag_levels["*"]<=t:this._global_level<=t}setLoggable(e,t){e&&e.name&&(e=e.name),this._tag_levels[e]=t,window.localStorage&&window.localStorage.setItem("log_tag_levels",JSON.stringify(this._tag_levels))}msg(e,t,r){t&&t.name&&(t=t.name),this.isLoggable(t,e)&&(t&&r.unshift(t+":"),r.unshift(`[${Log.Level.toStringTag(e)} ${(new Date).toTimeString().substr(0,8)}]`),console.error&&e>=Log.ERROR?console.error.apply(console,r):console.warn&&e>=Log.WARNING?console.warn.apply(console,r):console.info&&e>=Log.INFO?console.info.apply(console,r):console.debug&&e>=Log.DEBUG?console.debug.apply(console,r):console.trace&&e<=Log.TRACE?console.trace.apply(console,r):console.log.apply(console,r))}}Class.register(LogNative);class Log{static get instance(){return Log._instance||(Log._instance=new Log(new LogNative)),Log._instance}constructor(e){this._native=e}setLoggable(e,t){this._native.setLoggable(e,Log.Level.get(t))}get level(){return this._native._global_level}set level(e){this._native._global_level=Log.Level.get(e)}msg(e,t,r){if(this._native.isLoggable(t,e)){for(let e=0;e<r.length;++e)"function"==typeof r[e]&&(r[e]=r[e]()),"object"==typeof r[e]&&("function"==typeof r[e].toString?r[e]=r[e].toString():r[e].constructor&&r[e].constructor.name?r[e]=`{Object: ${r[e].constructor.name}}`:r[e]="{Object}");this._native.msg(e,t,r)}}static d(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.DEBUG,e,r)}static e(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.ERROR,e,r)}static i(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.INFO,e,r)}static v(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.VERBOSE,e,r)}static w(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.WARNING,e,r)}static t(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.TRACE,e,r)}}Log.Level={TRACE:1,VERBOSE:2,DEBUG:3,INFO:4,WARNING:5,ERROR:6,ASSERT:7,toStringTag:function(e){switch(e){case Log.Level.TRACE:return"T";case Log.Level.VERBOSE:return"V";case Log.Level.DEBUG:return"D";case Log.Level.INFO:return"I";case Log.Level.WARNING:return"W";case Log.Level.ERROR:return"E";case Log.Level.ASSERT:return"A";default:return"*"}},toString:function(e){switch(e){case Log.Level.TRACE:return"trace";case Log.Level.VERBOSE:return"verbose";case Log.Level.DEBUG:return"debug";case Log.Level.INFO:return"info";case Log.Level.WARNING:return"warn";case Log.Level.ERROR:return"error";case Log.Level.ASSERT:return"assert";default:return"unknown"}},get:function(e){if("number"==typeof e)return e;if(!isNaN(parseInt(e)))return parseInt(e);switch(e.toLowerCase()){case"t":case"trace":return Log.Level.TRACE;case"v":case"verbose":return Log.Level.VERBOSE;case"d":case"debug":return Log.Level.DEBUG;case"i":case"info":return Log.Level.INFO;case"w":case"warn":case"warning":return Log.Level.WARNING;case"e":case"error":case"exception":return Log.Level.ERROR;case"a":case"assert":case"assertion":return Log.Level.ASSERT}return 0}},Log.TRACE=Log.Level.TRACE,Log.VERBOSE=Log.Level.VERBOSE,Log.DEBUG=Log.Level.DEBUG,Log.INFO=Log.Level.INFO,Log.WARNING=Log.Level.WARNING,Log.ERROR=Log.Level.ERROR,Log.ASSERT=Log.Level.ASSERT,Log._instance=null,Log.d.tag=(e=>Log.d.bind(null,e)),Log.e.tag=(e=>Log.e.bind(null,e)),Log.i.tag=(e=>Log.i.bind(null,e)),Log.v.tag=(e=>Log.v.bind(null,e)),Log.w.tag=(e=>Log.w.bind(null,e)),Log.t.tag=(e=>Log.t.bind(null,e)),Class.register(Log);class IWorker{static async createProxy(e,t,r){return new(IWorker.Proxy(e))(r,t)}static async startWorkerForProxy(e,t,r){return IWorker._workersSupported?(r||(r=`${Nimiq._path}worker.js`),IWorker.createProxy(e,t,new Worker(URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${r.replace(/'/g,"")}');`]))))):(await IWorker._workerImplementation[e.name].init(t),IWorker._workerImplementation[e.name])}static async startWorkerPoolForProxy(e,t,r,i){return new(IWorker.Pool(e))(t=>IWorker.startWorkerForProxy(e,t,i),t,r).start()}static async stubBaseOnMessage(e){try{if("init"===e.data.command)if(IWorker._workerImplementation[e.data.args[0]]){const t=await IWorker._workerImplementation[e.data.args[0]].init(e.data.args[1]);self.postMessage({status:"OK",result:t,id:e.data.id})}else self.postMessage({status:"error",result:"Unknown worker!",id:e.data.id});else self.postMessage({status:"error",result:"Worker not yet initialized!",id:e.data.id})}catch(t){self.postMessage({status:"error",result:t,id:e.data.id})}}static get _workersSupported(){return"undefined"!=typeof Worker}static get areWorkersAsync(){return IWorker._workersSupported}static get _insideWebWorker(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope}static get _global(){return"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:null}static prepareForWorkerUse(e,t){IWorker._insideWebWorker&&(self.onmessage=IWorker.stubBaseOnMessage),IWorker._workerImplementation=IWorker._workerImplementation||{},IWorker._workerImplementation[e.name]=t}static _loadBrowserScript(e,t){const r=document.getElementsByTagName("head")[0],i=document.createElement("script");i.type="text/javascript",i.src=e;const s=()=>setTimeout(t,100);i.onreadystatechange=s,i.onload=s,r.appendChild(i)}static Proxy(e){const t=class extends e{constructor(t,r){return super(),this._name=r,this._messageId=0,this._worker=t,this._worker.onmessage=this._receive.bind(this),this._waiting=new Map,this._invoke("init",[e.name,r]).then(()=>this)}_receive(e){const t=this._waiting.get(e.data.id);t?(this._waiting.delete(e.data.id),"OK"===e.data.status?t.resolve(e.data.result):"error"===e.data.status&&t.error(e.data.result)):Log.w(WorkerProxy,"Unknown reply",e)}_invoke(e,t=[]){return new Promise((r,i)=>{const s={command:e,args:t,id:this._messageId++};this._waiting.set(s.id,{resolve:r,error:i}),this._worker.postMessage(s)})}destroy(){return this._invoke("destroy")}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(...e){return this._invoke(r,e)});return t}static Stub(e){const t=class extends e{constructor(){super()}_result(e,t,r){self.postMessage({status:t,result:r,id:e.data.id})}_onmessage(e){try{const t=this._invoke(e.data.command,e.data.args);t instanceof Promise?t.then(t=>{this._result(e,"OK",t)}):this._result(e,"OK",t)}catch(t){this._result(e,"error",t.message||t)}}init(e){this._name=e,IWorker._insideWebWorker&&(self.name=e,self.onmessage=(e=>this._onmessage(e)))}_invoke(e,t){return this[e].apply(this,t)}destroy(){IWorker._insideWebWorker&&self.close()}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(){throw`Not implemented in IWorker Stub: ${r}`});return t}static Pool(e){const t=class extends e{constructor(e,t="pool",r=1){super(),this._proxyInitializer=e,this._name=t,this._poolSize=r,this._workers=[],this._freeWorkers=[],this._waitingCalls=[]}async start(){return await this._updateToSize(),this}get poolSize(){return this._poolSize}set poolSize(e){this._poolSize=e,this._updateToSize().catch(Log.w.tag(IWorker))}destroy(){return this._poolSize=0,this._updateToSize()}_invoke(e,t){return IWorker._workersSupported?new Promise((r,i)=>{this._waitingCalls.push({name:e,args:t,resolve:r,error:i});const s=this._freeWorkers.shift();s&&this._step(s).catch(Log.w.tag(IWorker))}):this._workers[0][e].apply(this._workers[0],t)}async _step(e){let t=this._waitingCalls.shift();for(;t;){try{t.resolve(await e[t.name].apply(e,t.args))}catch(e){t.error(e)}if(-1===this._workers.indexOf(e))return void e.destroy();t=this._waitingCalls.shift()}this._freeWorkers.push(e)}async _updateToSize(){"undefined"==typeof Worker&&this._poolSize>1&&(Log.d(IWorker,"Pool of size larger than 1 requires WebWorker support."),this._poolSize=1);const e=[];for(;this._workers.length+e.length<this._poolSize;)e.push(this._proxyInitializer(`${this._name}#${this._workers.length+e.length}`));const t=await Promise.all(e);for(const e of t)this._workers.push(e),this._step(e).catch(Log.w.tag(IWorker));for(;this._workers.length>this._poolSize;){const e=this._freeWorkers.shift()||this._workers.pop(),t=this._workers.indexOf(e);t>=0&&(this._workers.splice(t,1),e.destroy())}return this}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(...e){return this._invoke(r,e)});return t}}IWorker._moduleLoadedCallbacks={},IWorker._workerImplementation={},Class.register(IWorker);class CryptoUtils{static computeHmacSha512(e,t){e.length>CryptoUtils.SHA512_BLOCK_SIZE&&(e=new SerialBuffer(Hash.computeSha512(e)));const r=new SerialBuffer(CryptoUtils.SHA512_BLOCK_SIZE),i=new SerialBuffer(CryptoUtils.SHA512_BLOCK_SIZE);for(let t=0;t<CryptoUtils.SHA512_BLOCK_SIZE;++t){const s=e[t]||0;r[t]=54^s,i[t]=92^s}const s=Hash.computeSha512(BufferUtils.concatTypedArrays(r,t));return Hash.computeSha512(BufferUtils.concatTypedArrays(i,s))}static computePBKDF2sha512(e,t,r,i){const s=Hash.SIZE.get(Hash.Algorithm.SHA512);if(i>(Math.pow(2,32)-1)*s)throw new Error("Derived key too long");const n=Math.ceil(i/s),a=i-(n-1)*s,o=new SerialBuffer(i);for(let i=1;i<=n;i++){let s=new SerialBuffer(t.length+4);s.write(t),s.writeUint32(i);const l=s=CryptoUtils.computeHmacSha512(e,s);for(let t=1;t<r;t++){s=CryptoUtils.computeHmacSha512(e,s);for(let e=0;e<l.length;e++)l[e]^=s[e]}i<n?o.write(l):o.write(l.slice(0,a))}return o}static async otpKdfLegacy(e,t,r,i){const s=await CryptoWorker.getInstanceAsync(),n=await s.kdfLegacy(t,r,i,e.byteLength);return BufferUtils.xor(e,n)}static async otpKdf(e,t,r,i){const s=await CryptoWorker.getInstanceAsync(),n=await s.kdf(t,r,i,e.byteLength);return BufferUtils.xor(e,n)}}CryptoUtils.SHA512_BLOCK_SIZE=128,Class.register(CryptoUtils);class CryptoWorker{static get lib(){return CryptoLib.instance}static async getInstanceAsync(){return CryptoWorker._workerAsync||(CryptoWorker._workerAsync=await IWorker.startWorkerPoolForProxy(CryptoWorker,"crypto",4)),CryptoWorker._workerAsync}async computeArgon2d(e){}async computeArgon2dBatch(e){}async kdfLegacy(e,t,r,i){}async kdf(e,t,r,i){}async blockVerify(e,t,r,i,s){}}CryptoWorker._workerAsync=null,Class.register(CryptoWorker);class CryptoWorkerImpl extends(IWorker.Stub(CryptoWorker)){constructor(){super(),this._superInit=super.init}async init(e){await this._superInit.call(this,e),PlatformUtils.isBrowser()&&await WasmHelper.doImportBrowser(),CryptoWorker._workerAsync=this}computeArgon2d(e){if(PlatformUtils.isNodeJs()){const t=new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D)),r=NodeNative.node_argon2(t,new Uint8Array(e),512);if(0!==r)throw r;return t}{let t;try{t=Module.stackSave();const r=Hash.getSize(Hash.Algorithm.ARGON2D),i=Module.stackAlloc(r),s=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e);const n=Module._nimiq_argon2(i,s,e.length,512);if(0!==n)throw n;const a=new Uint8Array(r);return a.set(new Uint8Array(Module.HEAPU8.buffer,i,r)),a}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==t&&Module.stackRestore(t)}}}computeArgon2dBatch(e){const t=[];if(PlatformUtils.isNodeJs()){for(const r of e){const e=new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D)),i=NodeNative.node_argon2(e,new Uint8Array(r),512);if(0!==i)throw i;t.push(e)}return t}{let r;try{r=Module.stackSave();const i=Hash.getSize(Hash.Algorithm.ARGON2D),s=Module.stackAlloc(i),n=Module.stackSave();for(const r of e){Module.stackRestore(n);const e=Module.stackAlloc(r.length);new Uint8Array(Module.HEAPU8.buffer,e,r.length).set(r);const a=Module._nimiq_argon2(s,e,r.length,512);if(0!==a)throw a;const o=new Uint8Array(i);o.set(new Uint8Array(Module.HEAPU8.buffer,s,i)),t.push(o)}return t}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==r&&Module.stackRestore(r)}}}kdfLegacy(e,t,r,i=Hash.getSize(Hash.Algorithm.ARGON2D)){if(PlatformUtils.isNodeJs()){const s=new Uint8Array(i),n=NodeNative.node_kdf_legacy(s,new Uint8Array(e),new Uint8Array(t),512,r);if(0!==n)throw n;return s}{let s;try{s=Module.stackSave();const n=Module.stackAlloc(i),a=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,a,e.length).set(e);const o=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,o,t.length).set(t);const l=Module._nimiq_kdf_legacy(n,i,a,e.length,o,t.length,512,r);if(0!==l)throw l;const c=new Uint8Array(i);return c.set(new Uint8Array(Module.HEAPU8.buffer,n,i)),c}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==s&&Module.stackRestore(s)}}}kdf(e,t,r,i=Hash.getSize(Hash.Algorithm.ARGON2D)){if(PlatformUtils.isNodeJs()){const s=new Uint8Array(i),n=NodeNative.node_kdf(s,new Uint8Array(e),new Uint8Array(t),512,r);if(0!==n)throw n;return s}{let s;try{s=Module.stackSave();const n=Module.stackAlloc(i),a=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,a,e.length).set(e);const o=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,o,t.length).set(t);const l=Module._nimiq_kdf(n,i,a,e.length,o,t.length,512,r);if(0!==l)throw l;const c=new Uint8Array(i);return c.set(new Uint8Array(Module.HEAPU8.buffer,n,i)),c}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==s&&Module.stackRestore(s)}}}async blockVerify(e,t,r,i,s){GenesisConfig={GENESIS_HASH:Hash.unserialize(new SerialBuffer(i)),NETWORK_ID:s};const n=Block.unserialize(new SerialBuffer(e));for(let e=0;e<t.length;e++)n.body.transactions[e]._valid=t[e];const a=await n._verify(r),o=await n.header.pow(),l=n.interlink.hash(),c=n.body.hash();return{valid:a,pow:o.serialize(),interlinkHash:l.serialize(),bodyHash:c.serialize()}}}IWorker.prepareForWorkerUse(CryptoWorker,new CryptoWorkerImpl),function(e){"use strict";var t,r=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,i=Math.ceil,s=Math.floor,n="[BigNumber Error] ",a=n+"Number primitive has more than 15 significant digits: ",o=1e14,l=14,c=9007199254740991,h=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],u=1e7,d=1e9;function f(e){var t=0|e;return e>0||e===t?t:t-1}function g(e){for(var t,r,i=1,s=e.length,n=e[0]+"";i<s;){for(t=e[i++]+"",r=l-t.length;r--;t="0"+t);n+=t}for(s=n.length;48===n.charCodeAt(--s););return n.slice(0,s+1||1)}function _(e,t){var r,i,s=e.c,n=t.c,a=e.s,o=t.s,l=e.e,c=t.e;if(!a||!o)return null;if(r=s&&!s[0],i=n&&!n[0],r||i)return r?i?0:-o:a;if(a!=o)return a;if(r=a<0,i=l==c,!s||!n)return i?0:!s^r?1:-1;if(!i)return l>c^r?1:-1;for(o=(l=s.length)<(c=n.length)?l:c,a=0;a<o;a++)if(s[a]!=n[a])return s[a]>n[a]^r?1:-1;return l==c?0:l>c^r?1:-1}function w(e,t,r,a){if(e<t||e>r||e!==(e<0?i(e):s(e)))throw Error(n+(a||"Argument")+("number"==typeof e?e<t||e>r?" out of range: ":" not an integer: ":" not a primitive number: ")+e)}function p(e){return"[object Array]"==Object.prototype.toString.call(e)}function y(e){var t=e.c.length-1;return f(e.e/l)==t&&e.c[t]%2!=0}function m(e,t){return(e.length>1?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function A(e,t,r){var i,s;if(t<0){for(s=r+".";++t;s+=r);e=s+e}else if(++t>(i=e.length)){for(s=r,t-=i;--t;s+=r);e+=s}else t<i&&(e=e.slice(0,t)+"."+e.slice(t));return e}(t=function e(t){var S,U,E,b,k,v,P,B,I,T=F.prototype={constructor:F,toString:null,valueOf:null},L=new F(1),M=20,H=4,N=-7,z=21,C=-1e7,O=1e7,R=!1,W=1,D=0,x={decimalSeparator:".",groupSeparator:",",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:" ",fractionGroupSize:0},K="0123456789abcdefghijklmnopqrstuvwxyz";function F(e,t){var i,n,o,h,u,d,f,g=this;if(!(g instanceof F))return new F(e,t);if(null==t){if(e instanceof F)return g.s=e.s,g.e=e.e,void(g.c=(e=e.c)?e.slice():e);if((u="number"==typeof e)&&0*e==0){if(g.s=1/e<0?(e=-e,-1):1,e===~~e){for(o=0,h=e;h>=10;h/=10,o++);return g.e=o,void(g.c=[e])}f=e+""}else{if(!r.test(f=e+""))return E(g,f,u);g.s=45==f.charCodeAt(0)?(f=f.slice(1),-1):1}}else{if(w(t,2,K.length,"Base"),f=e+"",10==t)return V(g=new F(e instanceof F?e:f),M+g.e+1,H);if(u="number"==typeof e){if(0*e!=0)return E(g,f,u,t);if(g.s=1/e<0?(f=f.slice(1),-1):1,F.DEBUG&&f.replace(/^0\.0*|\./,"").length>15)throw Error(a+e);u=!1}else g.s=45===f.charCodeAt(0)?(f=f.slice(1),-1):1,t>10&&t<37&&(f=f.toLowerCase());for(i=K.slice(0,t),o=h=0,d=f.length;h<d;h++)if(i.indexOf(n=f.charAt(h))<0){if("."==n&&h>o){o=d;continue}return E(g,e+"",u,t)}f=U(f,t,10,g.s)}for((o=f.indexOf("."))>-1&&(f=f.replace(".","")),(h=f.search(/e/i))>0?(o<0&&(o=h),o+=+f.slice(h+1),f=f.substring(0,h)):o<0&&(o=f.length),h=0;48===f.charCodeAt(h);h++);for(d=f.length;48===f.charCodeAt(--d););if(f=f.slice(h,++d)){if(d-=h,u&&F.DEBUG&&d>15&&(e>c||e!==s(e)))throw Error(a+g.s*e);if((o=o-h-1)>O)g.c=g.e=null;else if(o<C)g.c=[g.e=0];else{if(g.e=o,g.c=[],h=(o+1)%l,o<0&&(h+=l),h<d){for(h&&g.c.push(+f.slice(0,h)),d-=l;h<d;)g.c.push(+f.slice(h,h+=l));f=f.slice(h),h=l-f.length}else h-=d;for(;h--;f+="0");g.c.push(+f)}}else g.c=[g.e=0]}function q(e,t,r,i){var s,n,a,o,l;if(null==r?r=H:w(r,0,8),!e.c)return e.toString();if(s=e.c[0],a=e.e,null==t)l=g(e.c),l=1==i||2==i&&a<=N?m(l,a):A(l,a,"0");else if(n=(e=V(new F(e),t,r)).e,o=(l=g(e.c)).length,1==i||2==i&&(t<=n||n<=N)){for(;o<t;l+="0",o++);l=m(l,n)}else if(t-=a,l=A(l,n,"0"),n+1>o){if(--t>0)for(l+=".";t--;l+="0");}else if((t+=n-o)>0)for(n+1==o&&(l+=".");t--;l+="0");return e.s<0&&s?"-"+l:l}function Z(e,t){var r,i,s=0;for(p(e[0])&&(e=e[0]),r=new F(e[0]);++s<e.length;){if(!(i=new F(e[s])).s){r=i;break}t.call(r,i)&&(r=i)}return r}function G(e,t,r){for(var i=1,s=t.length;!t[--s];t.pop());for(s=t[0];s>=10;s/=10,i++);return(r=i+r*l-1)>O?e.c=e.e=null:r<C?e.c=[e.e=0]:(e.e=r,e.c=t),e}function V(e,t,r,n){var a,c,u,d,f,g,_,w=e.c,p=h;if(w){e:{for(a=1,d=w[0];d>=10;d/=10,a++);if((c=t-a)<0)c+=l,u=t,_=(f=w[g=0])/p[a-u-1]%10|0;else if((g=i((c+1)/l))>=w.length){if(!n)break e;for(;w.length<=g;w.push(0));f=_=0,a=1,u=(c%=l)-l+1}else{for(f=d=w[g],a=1;d>=10;d/=10,a++);_=(u=(c%=l)-l+a)<0?0:f/p[a-u-1]%10|0}if(n=n||t<0||null!=w[g+1]||(u<0?f:f%p[a-u-1]),n=r<4?(_||n)&&(0==r||r==(e.s<0?3:2)):_>5||5==_&&(4==r||n||6==r&&(c>0?u>0?f/p[a-u]:0:w[g-1])%10&1||r==(e.s<0?8:7)),t<1||!w[0])return w.length=0,n?(t-=e.e+1,w[0]=p[(l-t%l)%l],e.e=-t||0):w[0]=e.e=0,e;if(0==c?(w.length=g,d=1,g--):(w.length=g+1,d=p[l-c],w[g]=u>0?s(f/p[a-u]%p[u])*d:0),n)for(;;){if(0==g){for(c=1,u=w[0];u>=10;u/=10,c++);for(u=w[0]+=d,d=1;u>=10;u/=10,d++);c!=d&&(e.e++,w[0]==o&&(w[0]=1));break}if(w[g]+=d,w[g]!=o)break;w[g--]=0,d=1}for(c=w.length;0===w[--c];w.pop());}e.e>O?e.c=e.e=null:e.e<C&&(e.c=[e.e=0])}return e}return F.clone=e,F.ROUND_UP=0,F.ROUND_DOWN=1,F.ROUND_CEIL=2,F.ROUND_FLOOR=3,F.ROUND_HALF_UP=4,F.ROUND_HALF_DOWN=5,F.ROUND_HALF_EVEN=6,F.ROUND_HALF_CEIL=7,F.ROUND_HALF_FLOOR=8,F.EUCLID=9,F.config=F.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(n+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(w(r=e[t],0,d,t),M=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(w(r=e[t],0,8,t),H=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&(p(r=e[t])?(w(r[0],-d,0,t),w(r[1],0,d,t),N=r[0],z=r[1]):(w(r,-d,d,t),N=-(z=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if(p(r=e[t]))w(r[0],-d,-1,t),w(r[1],1,d,t),C=r[0],O=r[1];else{if(w(r,-d,d,t),!r)throw Error(n+t+" cannot be zero: "+r);C=-(O=r<0?-r:r)}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(n+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw R=!r,Error(n+"crypto unavailable");R=r}else R=r}if(e.hasOwnProperty(t="MODULO_MODE")&&(w(r=e[t],0,9,t),W=r),e.hasOwnProperty(t="POW_PRECISION")&&(w(r=e[t],0,d,t),D=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(n+t+" not an object: "+r);x=r}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.$|\.|(.).*\1/.test(r))throw Error(n+t+" invalid: "+r);K=r}}return{DECIMAL_PLACES:M,ROUNDING_MODE:H,EXPONENTIAL_AT:[N,z],RANGE:[C,O],CRYPTO:R,MODULO_MODE:W,POW_PRECISION:D,FORMAT:x,ALPHABET:K}},F.isBigNumber=function(e){return e instanceof F||e&&!0===e._isBigNumber||!1},F.maximum=F.max=function(){return Z(arguments,T.lt)},F.minimum=F.min=function(){return Z(arguments,T.gt)},F.random=(b=9007199254740992*Math.random()&2097151?function(){return s(9007199254740992*Math.random())}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,r,a,o,c,u=0,f=[],g=new F(L);if(null==e?e=M:w(e,0,d),o=i(e/l),R)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(o*=2));u<o;)(c=131072*t[u]+(t[u+1]>>>11))>=9e15?(r=crypto.getRandomValues(new Uint32Array(2)),t[u]=r[0],t[u+1]=r[1]):(f.push(c%1e14),u+=2);u=o/2}else{if(!crypto.randomBytes)throw R=!1,Error(n+"crypto unavailable");for(t=crypto.randomBytes(o*=7);u<o;)(c=281474976710656*(31&t[u])+1099511627776*t[u+1]+4294967296*t[u+2]+16777216*t[u+3]+(t[u+4]<<16)+(t[u+5]<<8)+t[u+6])>=9e15?crypto.randomBytes(7).copy(t,u):(f.push(c%1e14),u+=7);u=o/7}if(!R)for(;u<o;)(c=b())<9e15&&(f[u++]=c%1e14);for(o=f[--u],e%=l,o&&e&&(c=h[l-e],f[u]=s(o/c)*c);0===f[u];f.pop(),u--);if(u<0)f=[a=0];else{for(a=-1;0===f[0];f.splice(0,1),a-=l);for(u=1,c=f[0];c>=10;c/=10,u++);u<l&&(a-=l-u)}return g.e=a,g.c=f,g}),U=function(){function e(e,t,r,i){for(var s,n,a=[0],o=0,l=e.length;o<l;){for(n=a.length;n--;a[n]*=t);for(a[0]+=i.indexOf(e.charAt(o++)),s=0;s<a.length;s++)a[s]>r-1&&(null==a[s+1]&&(a[s+1]=0),a[s+1]+=a[s]/r|0,a[s]%=r)}return a.reverse()}return function(t,r,i,s,n){var a,o,l,c,h,u,d,f,_=t.indexOf("."),w=M,p=H;for(_>=0&&(c=D,D=0,t=t.replace(".",""),u=(f=new F(r)).pow(t.length-_),D=c,f.c=e(A(g(u.c),u.e,"0"),10,i,"0123456789"),f.e=f.c.length),l=c=(d=e(t,r,i,n?(a=K,"0123456789"):(a="0123456789",K))).length;0==d[--c];d.pop());if(!d[0])return a.charAt(0);if(_<0?--l:(u.c=d,u.e=l,u.s=s,d=(u=S(u,f,w,p,i)).c,h=u.r,l=u.e),_=d[o=l+w+1],c=i/2,h=h||o<0||null!=d[o+1],h=p<4?(null!=_||h)&&(0==p||p==(u.s<0?3:2)):_>c||_==c&&(4==p||h||6==p&&1&d[o-1]||p==(u.s<0?8:7)),o<1||!d[0])t=h?A(a.charAt(1),-w,a.charAt(0)):a.charAt(0);else{if(d.length=o,h)for(--i;++d[--o]>i;)d[o]=0,o||(++l,d=[1].concat(d));for(c=d.length;!d[--c];);for(_=0,t="";_<=c;t+=a.charAt(d[_++]));t=A(t,l,a.charAt(0))}return t}}(),S=function(){function e(e,t,r){var i,s,n,a,o=0,l=e.length,c=t%u,h=t/u|0;for(e=e.slice();l--;)o=((s=c*(n=e[l]%u)+(i=h*n+(a=e[l]/u|0)*c)%u*u+o)/r|0)+(i/u|0)+h*a,e[l]=s%r;return o&&(e=[o].concat(e)),e}function t(e,t,r,i){var s,n;if(r!=i)n=r>i?1:-1;else for(s=n=0;s<r;s++)if(e[s]!=t[s]){n=e[s]>t[s]?1:-1;break}return n}function r(e,t,r,i){for(var s=0;r--;)e[r]-=s,s=e[r]<t[r]?1:0,e[r]=s*i+e[r]-t[r];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(i,n,a,c,h){var u,d,g,_,w,p,y,m,A,S,U,E,b,k,v,P,B,I=i.s==n.s?1:-1,T=i.c,L=n.c;if(!(T&&T[0]&&L&&L[0]))return new F(i.s&&n.s&&(T?!L||T[0]!=L[0]:L)?T&&0==T[0]||!L?0*I:I/0:NaN);for(A=(m=new F(I)).c=[],I=a+(d=i.e-n.e)+1,h||(h=o,d=f(i.e/l)-f(n.e/l),I=I/l|0),g=0;L[g]==(T[g]||0);g++);if(L[g]>(T[g]||0)&&d--,I<0)A.push(1),_=!0;else{for(k=T.length,P=L.length,g=0,I+=2,(w=s(h/(L[0]+1)))>1&&(L=e(L,w,h),T=e(T,w,h),P=L.length,k=T.length),b=P,U=(S=T.slice(0,P)).length;U<P;S[U++]=0);B=L.slice(),B=[0].concat(B),v=L[0],L[1]>=h/2&&v++;do{if(w=0,(u=t(L,S,P,U))<0){if(E=S[0],P!=U&&(E=E*h+(S[1]||0)),(w=s(E/v))>1)for(w>=h&&(w=h-1),y=(p=e(L,w,h)).length,U=S.length;1==t(p,S,y,U);)w--,r(p,P<y?B:L,y,h),y=p.length,u=1;else 0==w&&(u=w=1),y=(p=L.slice()).length;if(y<U&&(p=[0].concat(p)),r(S,p,U,h),U=S.length,-1==u)for(;t(L,S,P,U)<1;)w++,r(S,P<U?B:L,U,h),U=S.length}else 0===u&&(w++,S=[0]);A[g++]=w,S[0]?S[U++]=T[b]||0:(S=[T[b]],U=1)}while((b++<k||null!=S[0])&&I--);_=null!=S[0],A[0]||A.splice(0,1)}if(h==o){for(g=1,I=A[0];I>=10;I/=10,g++);V(m,a+(m.e=g+d*l-1)+1,c,_)}else m.e=d,m.r=+_;return m}}(),k=/^(-?)0([xbo])(?=\w[\w.]*$)/i,v=/^([^.]+)\.$/,P=/^\.([^.]+)$/,B=/^-?(Infinity|NaN)$/,I=/^\s*\+(?=[\w.])|^\s+|\s+$/g,E=function(e,t,r,i){var s,a=r?t:t.replace(I,"");if(B.test(a))e.s=isNaN(a)?null:a<0?-1:1,e.c=e.e=null;else{if(!r&&(a=a.replace(k,function(e,t,r){return s="x"==(r=r.toLowerCase())?16:"b"==r?2:8,i&&i!=s?e:t}),i&&(s=i,a=a.replace(v,"$1").replace(P,"0.$1")),t!=a))return new F(a,s);if(F.DEBUG)throw Error(n+"Not a"+(i?" base "+i:"")+" number: "+t);e.c=e.e=e.s=null}},T.absoluteValue=T.abs=function(){var e=new F(this);return e.s<0&&(e.s=1),e},T.comparedTo=function(e,t){return _(this,new F(e,t))},T.decimalPlaces=T.dp=function(e,t){var r,i,s,n=this;if(null!=e)return w(e,0,d),null==t?t=H:w(t,0,8),V(new F(n),e+n.e+1,t);if(!(r=n.c))return null;if(i=((s=r.length-1)-f(this.e/l))*l,s=r[s])for(;s%10==0;s/=10,i--);return i<0&&(i=0),i},T.dividedBy=T.div=function(e,t){return S(this,new F(e,t),M,H)},T.dividedToIntegerBy=T.idiv=function(e,t){return S(this,new F(e,t),0,1)},T.exponentiatedBy=T.pow=function(e,t){var r,a,o,c,h,u,d,f=this;if((e=new F(e)).c&&!e.isInteger())throw Error(n+"Exponent not an integer: "+e);if(null!=t&&(t=new F(t)),c=e.e>14,!f.c||!f.c[0]||1==f.c[0]&&!f.e&&1==f.c.length||!e.c||!e.c[0])return d=new F(Math.pow(+f.valueOf(),c?2-y(e):+e)),t?d.mod(t):d;if(h=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new F(NaN);(a=!h&&f.isInteger()&&t.isInteger())&&(f=f.mod(t))}else{if(e.e>9&&(f.e>0||f.e<-1||(0==f.e?f.c[0]>1||c&&f.c[1]>=24e7:f.c[0]<8e13||c&&f.c[0]<=9999975e7)))return o=f.s<0&&y(e)?-0:0,f.e>-1&&(o=1/o),new F(h?1/o:o);D&&(o=i(D/l+2))}for(c?(r=new F(.5),u=y(e)):u=e%2,h&&(e.s=1),d=new F(L);;){if(u){if(!(d=d.times(f)).c)break;o?d.c.length>o&&(d.c.length=o):a&&(d=d.mod(t))}if(c){if(V(e=e.times(r),e.e+1,1),!e.c[0])break;c=e.e>14,u=y(e)}else{if(!(e=s(e/2)))break;u=e%2}f=f.times(f),o?f.c&&f.c.length>o&&(f.c.length=o):a&&(f=f.mod(t))}return a?d:(h&&(d=L.div(d)),t?d.mod(t):o?V(d,D,H,void 0):d)},T.integerValue=function(e){var t=new F(this);return null==e?e=H:w(e,0,8),V(t,t.e+1,e)},T.isEqualTo=T.eq=T.equals=function(e,t){return 0===_(this,new F(e,t))},T.isFinite=function(){return!!this.c},T.isGreaterThan=T.gt=function(e,t){return _(this,new F(e,t))>0},T.isGreaterThanOrEqualTo=T.gte=function(e,t){return 1===(t=_(this,new F(e,t)))||0===t},T.isInteger=function(){return!!this.c&&f(this.e/l)>this.c.length-2},T.isLessThan=T.lt=function(e,t){return _(this,new F(e,t))<0},T.isLessThanOrEqualTo=T.lte=function(e,t){return-1===(t=_(this,new F(e,t)))||0===t},T.isNaN=function(){return!this.s},T.isNegative=function(){return this.s<0},T.isPositive=function(){return this.s>0},T.isZero=function(){return!!this.c&&0==this.c[0]},T.minus=function(e,t){var r,i,s,n,a=this,c=a.s;if(t=(e=new F(e,t)).s,!c||!t)return new F(NaN);if(c!=t)return e.s=-t,a.plus(e);var h=a.e/l,u=e.e/l,d=a.c,g=e.c;if(!h||!u){if(!d||!g)return d?(e.s=-t,e):new F(g?a:NaN);if(!d[0]||!g[0])return g[0]?(e.s=-t,e):new F(d[0]?a:3==H?-0:0)}if(h=f(h),u=f(u),d=d.slice(),c=h-u){for((n=c<0)?(c=-c,s=d):(u=h,s=g),s.reverse(),t=c;t--;s.push(0));s.reverse()}else for(i=(n=(c=d.length)<(t=g.length))?c:t,c=t=0;t<i;t++)if(d[t]!=g[t]){n=d[t]<g[t];break}if(n&&(s=d,d=g,g=s,e.s=-e.s),(t=(i=g.length)-(r=d.length))>0)for(;t--;d[r++]=0);for(t=o-1;i>c;){if(d[--i]<g[i]){for(r=i;r&&!d[--r];d[r]=t);--d[r],d[i]+=o}d[i]-=g[i]}for(;0==d[0];d.splice(0,1),--u);return d[0]?G(e,d,u):(e.s=3==H?-1:1,e.c=[e.e=0],e)},T.modulo=T.mod=function(e,t){var r,i,s=this;return e=new F(e,t),!s.c||!e.s||e.c&&!e.c[0]?new F(NaN):!e.c||s.c&&!s.c[0]?new F(s):(9==W?(i=e.s,e.s=1,r=S(s,e,0,3),e.s=i,r.s*=i):r=S(s,e,0,W),(e=s.minus(r.times(e))).c[0]||1!=W||(e.s=s.s),e)},T.multipliedBy=T.times=function(e,t){var r,i,s,n,a,c,h,d,g,_,w,p,y,m,A,S=this,U=S.c,E=(e=new F(e,t)).c;if(!(U&&E&&U[0]&&E[0]))return!S.s||!e.s||U&&!U[0]&&!E||E&&!E[0]&&!U?e.c=e.e=e.s=null:(e.s*=S.s,U&&E?(e.c=[0],e.e=0):e.c=e.e=null),e;for(i=f(S.e/l)+f(e.e/l),e.s*=S.s,(h=U.length)<(_=E.length)&&(y=U,U=E,E=y,s=h,h=_,_=s),s=h+_,y=[];s--;y.push(0));for(m=o,A=u,s=_;--s>=0;){for(r=0,w=E[s]%A,p=E[s]/A|0,n=s+(a=h);n>s;)r=((d=w*(d=U[--a]%A)+(c=p*d+(g=U[a]/A|0)*w)%A*A+y[n]+r)/m|0)+(c/A|0)+p*g,y[n--]=d%m;y[n]=r}return r?++i:y.splice(0,1),G(e,y,i)},T.negated=function(){var e=new F(this);return e.s=-e.s||null,e},T.plus=function(e,t){var r,i=this,s=i.s;if(t=(e=new F(e,t)).s,!s||!t)return new F(NaN);if(s!=t)return e.s=-t,i.minus(e);var n=i.e/l,a=e.e/l,c=i.c,h=e.c;if(!n||!a){if(!c||!h)return new F(s/0);if(!c[0]||!h[0])return h[0]?e:new F(c[0]?i:0*s)}if(n=f(n),a=f(a),c=c.slice(),s=n-a){for(s>0?(a=n,r=h):(s=-s,r=c),r.reverse();s--;r.push(0));r.reverse()}for((s=c.length)-(t=h.length)<0&&(r=h,h=c,c=r,t=s),s=0;t;)s=(c[--t]=c[t]+h[t]+s)/o|0,c[t]=o===c[t]?0:c[t]%o;return s&&(c=[s].concat(c),++a),G(e,c,a)},T.precision=T.sd=function(e,t){var r,i,s,n=this;if(null!=e&&e!==!!e)return w(e,1,d),null==t?t=H:w(t,0,8),V(new F(n),e,t);if(!(r=n.c))return null;if(i=(s=r.length-1)*l+1,s=r[s]){for(;s%10==0;s/=10,i--);for(s=r[0];s>=10;s/=10,i++);}return e&&n.e+1>i&&(i=n.e+1),i},T.shiftedBy=function(e){return w(e,-c,c),this.times("1e"+e)},T.squareRoot=T.sqrt=function(){var e,t,r,i,s,n=this,a=n.c,o=n.s,l=n.e,c=M+4,h=new F("0.5");if(1!==o||!a||!a[0])return new F(!o||o<0&&(!a||a[0])?NaN:a?n:1/0);if(0==(o=Math.sqrt(+n))||o==1/0?(((t=g(a)).length+l)%2==0&&(t+="0"),o=Math.sqrt(t),l=f((l+1)/2)-(l<0||l%2),r=new F(t=o==1/0?"1e"+l:(t=o.toExponential()).slice(0,t.indexOf("e")+1)+l)):r=new F(o+""),r.c[0])for((o=(l=r.e)+c)<3&&(o=0);;)if(s=r,r=h.times(s.plus(S(n,s,c,1))),g(s.c).slice(0,o)===(t=g(r.c)).slice(0,o)){if(r.e<l&&--o,"9999"!=(t=t.slice(o-3,o+1))&&(i||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(V(r,r.e+M+2,1),e=!r.times(r).eq(n));break}if(!i&&(V(s,s.e+M+2,0),s.times(s).eq(n))){r=s;break}c+=4,o+=4,i=1}return V(r,r.e+M+1,H,e)},T.toExponential=function(e,t){return null!=e&&(w(e,0,d),e++),q(this,e,t,1)},T.toFixed=function(e,t){return null!=e&&(w(e,0,d),e=e+this.e+1),q(this,e,t)},T.toFormat=function(e,t){var r=this.toFixed(e,t);if(this.c){var i,s=r.split("."),n=+x.groupSize,a=+x.secondaryGroupSize,o=x.groupSeparator,l=s[0],c=s[1],h=this.s<0,u=h?l.slice(1):l,d=u.length;if(a&&(i=n,n=a,a=i,d-=i),n>0&&d>0){for(i=d%n||n,l=u.substr(0,i);i<d;i+=n)l+=o+u.substr(i,n);a>0&&(l+=o+u.slice(i)),h&&(l="-"+l)}r=c?l+x.decimalSeparator+((a=+x.fractionGroupSize)?c.replace(new RegExp("\\d{"+a+"}\\B","g"),"$&"+x.fractionGroupSeparator):c):l}return r},T.toFraction=function(e){var t,r,i,s,a,o,c,u,d,f,_,w,p=this,y=p.c;if(null!=e&&(!(u=new F(e)).isInteger()&&(u.c||1!==u.s)||u.lt(L)))throw Error(n+"Argument "+(u.isInteger()?"out of range: ":"not an integer: ")+e);if(!y)return p.toString();for(r=new F(L),f=i=new F(L),s=d=new F(L),w=g(y),o=r.e=w.length-p.e-1,r.c[0]=h[(c=o%l)<0?l+c:c],e=!e||u.comparedTo(r)>0?o>0?r:f:u,c=O,O=1/0,u=new F(w),d.c[0]=0;_=S(u,r,0,1),1!=(a=i.plus(_.times(s))).comparedTo(e);)i=s,s=a,f=d.plus(_.times(a=f)),d=a,r=u.minus(_.times(a=r)),u=a;return a=S(e.minus(i),s,0,1),d=d.plus(a.times(f)),i=i.plus(a.times(s)),d.s=f.s=p.s,t=S(f,s,o*=2,H).minus(p).abs().comparedTo(S(d,i,o,H).minus(p).abs())<1?[f.toString(),s.toString()]:[d.toString(),i.toString()],O=c,t},T.toNumber=function(){return+this},T.toPrecision=function(e,t){return null!=e&&w(e,1,d),q(this,e,t,2)},T.toString=function(e){var t,r=this,i=r.s,s=r.e;return null===s?i?(t="Infinity",i<0&&(t="-"+t)):t="NaN":(t=g(r.c),null==e?t=s<=N||s>=z?m(t,s):A(t,s,"0"):(w(e,2,K.length,"Base"),t=U(A(t,s,"0"),10,e,i,!0)),i<0&&r.c[0]&&(t="-"+t)),t},T.valueOf=T.toJSON=function(){var e,t=this,r=t.e;return null===r?t.toString():(e=g(t.c),e=r<=N||r>=z?m(e,r):A(e,r,"0"),t.s<0?"-"+e:e)},T._isBigNumber=!0,null!=t&&F.set(t),F}()).default=t.BigNumber=t,e.BigNumber=t}(Class.scope);const BigNumber=Class.scope.BigNumber;BigNumber.config({DECIMAL_PLACES:10});class NumberUtils{static isUint8(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT8_MAX}static isUint16(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT16_MAX}static isUint32(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT32_MAX}static isUint64(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT64_MAX}static randomUint32(){return Math.floor(Math.random()*(NumberUtils.UINT32_MAX+1))}static randomUint64(){return Math.floor(Math.random()*(NumberUtils.UINT64_MAX+1))}static fromBinary(e){return parseInt(e,2)}}NumberUtils.UINT8_MAX=255,NumberUtils.UINT16_MAX=65535,NumberUtils.UINT32_MAX=4294967295,NumberUtils.UINT64_MAX=Number.MAX_SAFE_INTEGER,Class.register(NumberUtils);class BufferUtils{static toAscii(e){const t=BufferUtils._toUint8View(e);let r="";for(let e=0;e<t.length;e+=8192)r+=String.fromCharCode.apply(null,t.subarray(e,e+8192));return r}static fromAscii(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t[r]=e.charCodeAt(r);return t}static _codePointTextDecoder(e){if("undefined"==typeof TextDecoder)throw new Error("TextDecoder not supported");if(null===BufferUtils._ISO_8859_15_DECODER)throw new Error("TextDecoder does not support iso-8859-15");if(void 0===BufferUtils._ISO_8859_15_DECODER)try{BufferUtils._ISO_8859_15_DECODER=new TextDecoder("iso-8859-15")}catch(e){throw BufferUtils._ISO_8859_15_DECODER=null,new Error("TextDecoder does not support iso-8859-15")}const t=BufferUtils._toUint8View(e);return BufferUtils._ISO_8859_15_DECODER.decode(t).replace("€","¤").replace("Š","¦").replace("š","¨").replace("Ž","´").replace("ž","¸").replace("Œ","¼").replace("œ","½").replace("Ÿ","¾")}static _tripletToBase64(e){return BufferUtils._BASE64_LOOKUP[e>>18&63]+BufferUtils._BASE64_LOOKUP[e>>12&63]+BufferUtils._BASE64_LOOKUP[e>>6&63]+BufferUtils._BASE64_LOOKUP[63&e]}static _base64encodeChunk(e,t,r){let i;const s=[];for(let n=t;n<r;n+=3)i=(e[n]<<16&16711680)+(e[n+1]<<8&65280)+(255&e[n+2]),s.push(BufferUtils._tripletToBase64(i));return s.join("")}static _base64fromByteArray(e){let t;const r=e.length,i=r%3;let s="";const n=[];for(let t=0,s=r-i;t<s;t+=16383)n.push(BufferUtils._base64encodeChunk(e,t,t+16383>s?s:t+16383));return 1===i?(t=e[r-1],s+=BufferUtils._BASE64_LOOKUP[t>>2],s+=BufferUtils._BASE64_LOOKUP[t<<4&63],s+="=="):2===i&&(t=(e[r-2]<<8)+e[r-1],s+=BufferUtils._BASE64_LOOKUP[t>>10],s+=BufferUtils._BASE64_LOOKUP[t>>4&63],s+=BufferUtils._BASE64_LOOKUP[t<<2&63],s+="="),n.push(s),n.join("")}static toBase64(e){if(PlatformUtils.isNodeJs())return Buffer.from(e).toString("base64");if("undefined"!=typeof TextDecoder&&null!==BufferUtils._ISO_8859_15_DECODER)try{return btoa(BufferUtils._codePointTextDecoder(e))}catch(e){}return BufferUtils._base64fromByteArray(BufferUtils._toUint8View(e))}static fromBase64(e){return new SerialBuffer(Uint8Array.from(atob(e),e=>e.charCodeAt(0)))}static toBase64Url(e){return BufferUtils.toBase64(e).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,".")}static fromBase64Url(e){return new SerialBuffer(Uint8Array.from(atob(e.replace(/_/g,"/").replace(/-/g,"+").replace(/\./g,"=")),e=>e.charCodeAt(0)))}static toBase32(e,t=BufferUtils.BASE32_ALPHABET.NIMIQ){let r,i,s,n=3,a=0,o="";for(s=0;s<e.length;s++)o+=t[31&(i=a|(r=e[s])>>n)],n>5&&(o+=t[31&(i=r>>(n-=5))]),a=r<<(n=5-n),n=8-n;for(3!==n&&(o+=t[31&a]);o.length%8!=0&&33===t.length;)o+=t[32];return o}static fromBase32(e,t=BufferUtils.BASE32_ALPHABET.NIMIQ){const r=[];t.toUpperCase().split("").forEach((e,t)=>{e in r||(r[e]=t)});let i,s=8,n=0,a=[];return e.toUpperCase().split("").forEach(e=>{33===t.length&&e===t[32]||(i=255&r[e],(s-=5)>0?n|=i<<s:s<0?(a.push(n|i>>-s),n=i<<(s+=8)&255):(a.push(n|i),s=8,n=0))}),8!==s&&0!==n&&a.push(n),new Uint8Array(a)}static toHex(e){let t="";for(let r=0;r<e.length;r++){const i=e[r];t+=BufferUtils.HEX_ALPHABET[i>>>4],t+=BufferUtils.HEX_ALPHABET[15&i]}return t}static fromHex(e){return e=e.trim(),StringUtils.isHexBytes(e)?new SerialBuffer(Uint8Array.from(e.match(/.{2}/g)||[],e=>parseInt(e,16))):null}static toBinary(e){let t="";for(let r=0;r<e.length;r++){const i=e[r];t+=StringUtils.lpad(i.toString(2),"0",8)}return t}static _strToUint8Array(e){const t=[];let r=0;for(let i=0;i<e.length;i++){let s=e.charCodeAt(i);s<128?t[r++]=s:s<2048?(t[r++]=s>>6|192,t[r++]=63&s|128):55296==(64512&s)&&i+1<e.length&&56320==(64512&e.charCodeAt(i+1))?(s=65536+((1023&s)<<10)+(1023&e.charCodeAt(++i)),t[r++]=s>>18|240,t[r++]=s>>12&63|128,t[r++]=s>>6&63|128,t[r++]=63&s|128):(t[r++]=s>>12|224,t[r++]=s>>6&63|128,t[r++]=63&s|128)}return new Uint8Array(t)}static _utf8TextEncoder(e){if("undefined"==typeof TextEncoder)throw new Error("TextEncoder not supported");if(null===BufferUtils._UTF8_ENCODER)throw new Error("TextEncoder does not support utf8");if(void 0===BufferUtils._UTF8_ENCODER)try{BufferUtils._UTF8_ENCODER=new TextEncoder}catch(e){throw BufferUtils._UTF8_ENCODER=null,new Error("TextEncoder does not support utf8")}return BufferUtils._UTF8_ENCODER.encode(e)}static fromUtf8(e){if(PlatformUtils.isNodeJs())return Buffer.from(e);if("undefined"!=typeof TextEncoder&&null!==BufferUtils._UTF8_ENCODER)try{return BufferUtils._utf8TextEncoder(e)}catch(e){}return BufferUtils._strToUint8Array(e)}static concatTypedArrays(e,t){const r=new e.constructor(e.length+t.length);return r.set(e,0),r.set(t,e.length),r}static equals(e,t){if((e.byteLength||e.length)!==(t.byteLength||t.length))return!1;const r=BufferUtils._toUint8View(e),i=BufferUtils._toUint8View(t);for(let e=0;e<r.length;e++)if(r[e]!==i[e])return!1;return!0}static compare(e,t){if(e.length<t.length)return-1;if(e.length>t.length)return 1;for(let r=0;r<e.length;r++){if(e[r]<t[r])return-1;if(e[r]>t[r])return 1}return 0}static xor(e,t){const r=new Uint8Array(e.byteLength);for(let i=0;i<e.byteLength;++i)r[i]=e[i]^t[i];return r}static _toUint8View(e){return e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):e.buffer instanceof ArrayBuffer?new Uint8Array(e.buffer):Uint8Array.from(e)}}BufferUtils.BASE64_ALPHABET="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",BufferUtils.BASE32_ALPHABET={RFC4648:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",RFC4648_HEX:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",NIMIQ:"0123456789ABCDEFGHJKLMNPQRSTUVXY"},BufferUtils.HEX_ALPHABET="0123456789abcdef",BufferUtils._BASE64_LOOKUP=[];for(let e=0,t=BufferUtils.BASE64_ALPHABET.length;e<t;++e)BufferUtils._BASE64_LOOKUP[e]=BufferUtils.BASE64_ALPHABET[e];Class.register(BufferUtils);class SerialBuffer extends Uint8Array{constructor(e){super(e),this._view=new DataView(this.buffer),this._readPos=0,this._writePos=0}subarray(e,t){return ArrayUtils.subarray(this,e,t)}get readPos(){return this._readPos}set readPos(e){if(e<0||e>this.byteLength)throw`Invalid readPos ${e}`;this._readPos=e}get writePos(){return this._writePos}set writePos(e){if(e<0||e>this.byteLength)throw`Invalid writePos ${e}`;this._writePos=e}reset(){this._readPos=0,this._writePos=0}read(e){const t=this.subarray(this._readPos,this._readPos+e);return this._readPos+=e,new Uint8Array(t)}write(e){this.set(e,this._writePos),this._writePos+=e.byteLength}readUint8(){return this._view.getUint8(this._readPos++)}writeUint8(e){this._view.setUint8(this._writePos++,e)}readUint16(){const e=this._view.getUint16(this._readPos);return this._readPos+=2,e}writeUint16(e){this._view.setUint16(this._writePos,e),this._writePos+=2}readUint32(){const e=this._view.getUint32(this._readPos);return this._readPos+=4,e}writeUint32(e){this._view.setUint32(this._writePos,e),this._writePos+=4}readUint64(){const e=this._view.getUint32(this._readPos)*Math.pow(2,32)+this._view.getUint32(this._readPos+4);if(!NumberUtils.isUint64(e))throw new Error("Malformed value");return this._readPos+=8,e}writeUint64(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");this._view.setUint32(this._writePos,Math.floor(e/Math.pow(2,32))),this._view.setUint32(this._writePos+4,e),this._writePos+=8}readVarUint(){const e=this.readUint8();return e<253?e:253===e?this.readUint16():254===e?this.readUint32():this.readUint64()}writeVarUint(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");e<253?this.writeUint8(e):e<=65535?(this.writeUint8(253),this.writeUint16(e)):e<=4294967295?(this.writeUint8(254),this.writeUint32(e)):(this.writeUint8(255),this.writeUint64(e))}static varUintSize(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");return e<253?1:e<=65535?3:e<=4294967295?5:9}readFloat64(){const e=this._view.getFloat64(this._readPos);return this._readPos+=8,e}writeFloat64(e){this._view.setFloat64(this._writePos,e),this._writePos+=8}readString(e){const t=this.read(e);return BufferUtils.toAscii(t)}writeString(e,t){if(StringUtils.isMultibyte(e)||e.length!==t)throw"Malformed value/length";const r=BufferUtils.fromAscii(e);this.write(r)}readPaddedString(e){const t=this.read(e);let r=0;for(;r<e&&0!==t[r];)r++;const i=new Uint8Array(t.buffer,t.byteOffset,r);return BufferUtils.toAscii(i)}writePaddedString(e,t){if(StringUtils.isMultibyte(e)||e.length>t)throw"Malformed value/length";const r=BufferUtils.fromAscii(e);this.write(r);const i=t-r.byteLength;this.write(new Uint8Array(i))}readVarLengthString(){const e=this.readUint8();if(this._readPos+e>this.length)throw"Malformed length";const t=this.read(e);return BufferUtils.toAscii(t)}writeVarLengthString(e){if(StringUtils.isMultibyte(e)||!NumberUtils.isUint8(e.length))throw new Error("Malformed value");const t=BufferUtils.fromAscii(e);this.writeUint8(t.byteLength),this.write(t)}static varLengthStringSize(e){if(StringUtils.isMultibyte(e)||!NumberUtils.isUint8(e.length))throw new Error("Malformed value");return 1+e.length}}Class.register(SerialBuffer);class MinerWorker{async multiMine(e,t,r,i){}}Class.register(MinerWorker);class MinerWorkerImpl extends(IWorker.Stub(MinerWorker)){constructor(){super(),this._superInit=super.init}async init(e){await this._superInit.call(this,e),PlatformUtils.isBrowser()&&await WasmHelper.doImportBrowser()}async multiMine(e,t,r,i){const s=new Uint8Array(32);let n,a;try{n=Module._malloc(s.length),a=Module._malloc(e.length),Module.HEAPU8.set(e,a);const o=Module._nimiq_argon2_target(n,a,e.length,t,r,i,512);return o!==i&&(s.set(new Uint8Array(Module.HEAPU8.buffer,n,s.length)),{hash:s,nonce:o})}catch(e){throw Log.w(MinerWorkerImpl,e),e}finally{void 0!==n&&Module._free(n),void 0!==a&&Module._free(a)}}}IWorker.prepareForWorkerUse(MinerWorker,new MinerWorkerImpl);class MinerWorkerPool extends(IWorker.Pool(MinerWorker)){constructor(e=1){super(e=>IWorker.startWorkerForProxy(MinerWorker,e),"miner",e),this._miningEnabled=!1,this._activeNonces=[],this._block=null,this._noncesPerRun=256,this._observable=new Observable,this._shareCompact=Policy.BLOCK_TARGET_MAX,this._runsPerCycle=1/0,this._cycleWait=100,this._superUpdateToSize=super._updateToSize,PlatformUtils.isNodeJs()&&(Log.i(MinerWorkerPool,`Using add-on optimized for instruction set: ${cpuSupport}`),this.multiMine=function(e,t,r,i){return new Promise((s,n)=>{NodeNative.node_argon2_target_async(async t=>{try{if(t===i)s(!1);else{e.writePos-=4,e.writeUint32(t);const r=await(await CryptoWorker.getInstanceAsync()).computeArgon2d(e);s({hash:r,nonce:t})}}catch(e){n(e)}},e,t,r,i,512)})})}get noncesPerRun(){return this._noncesPerRun}set noncesPerRun(e){this._noncesPerRun=e}get runsPerCycle(){return this._runsPerCycle}set runsPerCycle(e){this._runsPerCycle=e}get cycleWait(){return this._cycleWait}set cycleWait(e){this._cycleWait=e}on(e,t){return this._observable.on(e,t)}off(e,t){this._observable.off(e,t)}async startMiningOnBlock(e,t){if(this._block=e,this._shareCompact=t||e.nBits,this._miningEnabled)this._activeNonces=[{minNonce:0,maxNonce:0}];else{await this._updateToSize(),this._activeNonces=[],this._miningEnabled=!0;for(let e=0;e<this.poolSize;++e)this._startMiner()}}stop(){this._miningEnabled=!1}async _updateToSize(){for(PlatformUtils.isNodeJs()||await this._superUpdateToSize.call(this);this._miningEnabled&&this._activeNonces.length<this.poolSize;)this._startMiner()}_startMiner(){if(this._activeNonces.length>=this.poolSize)return;const e=0===this._activeNonces.length?0:Math.max.apply(null,this._activeNonces.map(e=>e.maxNonce)),t={minNonce:e,maxNonce:e+this._noncesPerRun};this._activeNonces.push(t),this._singleMiner(t).catch(e=>Log.e(MinerWorkerPool,e))}async _singleMiner(e){let t=0;for(;this._miningEnabled&&(IWorker.areWorkersAsync||PlatformUtils.isNodeJs()||0===t)&&t<this._runsPerCycle;){t++;const r=this._block,i=await this.multiMine(r.header.serialize(),this._shareCompact,e.minNonce,e.maxNonce);if(i){const e=new Hash(i.hash);this._observable.fire("share",{block:r,nonce:i.nonce,hash:e})}else this._observable.fire("no-share",{nonce:e.maxNonce});if(this._activeNonces.length>this.poolSize)return void this._activeNonces.splice(this._activeNonces.indexOf(e),1);{const t=Math.max.apply(null,this._activeNonces.map(e=>e.maxNonce)),r={minNonce:t,maxNonce:t+this._noncesPerRun};this._activeNonces.splice(this._activeNonces.indexOf(e),1,r),e=r}}this._miningEnabled&&setTimeout(()=>this._singleMiner(e),this._cycleWait)}}Class.register(MinerWorkerPool);class PlatformUtils{static isBrowser(){return!0}static isWeb(){return"undefined"!=typeof window}static isNodeJs(){return!1}static supportsWebRTC(){return!!(PlatformUtils.isBrowser()?window.RTCPeerConnection||window.webkitRTCPeerConnection:null)}static supportsWS(){return location&&"http:"===location.protocol}static isOnline(){return!("onLine"in window.navigator)||window.navigator.onLine}static isWindows(){return/^win/.test(window.navigator.platform)}static get userAgentString(){try{return window.navigator.platform}catch(e){return"unknown"}}static get hardwareConcurrency(){return"object"==typeof navigator&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:1}}Class.register(PlatformUtils);class WasmHelper{static async doImport(e){return WasmHelper.doImportBrowser(e)}static async doImportBrowser(e){WasmHelper._importBrowserPromise=WasmHelper._importBrowserPromise||(async()=>{!e&&await WasmHelper.importWasmBrowser("worker-wasm.wasm")?await WasmHelper.importScriptBrowser("worker-wasm.js"):await WasmHelper.importScriptBrowser("worker-js.js")})();try{await WasmHelper._importBrowserPromise}catch(e){throw WasmHelper._importBrowserPromise=null,e}}static async importWasm(e,t="Module"){return WasmHelper.importWasmBrowser(e,t)}static async importWasmBrowser(e,t="Module"){return e=WasmHelper._adjustWasmPath(e),WasmHelper._global.WebAssembly?new Promise(r=>{try{const i=new XMLHttpRequest;i.open("GET",e,!0),i.responseType="arraybuffer",i.onload=function(){WasmHelper._global[t]=WasmHelper._global[t]||{},WasmHelper._global[t].wasmBinary=i.response,r(!0)},i.onerror=function(){Log.w(WasmHelper,`Failed to access WebAssembly module ${e}`),r(!1)},i.send(null)}catch(t){Log.w(WasmHelper,`Failed to access WebAssembly module ${e}`),r(!1)}}):(Log.w(WasmHelper,"No support for WebAssembly available."),Promise.resolve(!1))}static async importScript(e,t="Module"){return WasmHelper.importScriptBrowser(e,t)}static async importScriptBrowser(e,t="Module"){if(t&&WasmHelper._global[t]&&WasmHelper._global[t].asm)return!1;e=WasmHelper._adjustScriptPath(e);const r=WasmHelper._global[t]||{};return new Promise(async(i,s)=>{t&&(r.onRuntimeInitialized=(()=>i(!0))),"function"==typeof importScripts?(await new Promise(r=>{WasmHelper._moduleLoadedCallbacks[t]=r,importScripts(e)}),WasmHelper._global[t]=WasmHelper._global[t](r),t||i(!0)):"object"==typeof window?(await new Promise(r=>{WasmHelper._moduleLoadedCallbacks[t]=r,WasmHelper._loadBrowserScript(e)}),WasmHelper._global[t]=WasmHelper._global[t](r),t||i(!0)):"function"==typeof require?(WasmHelper._global[t]=require(e)(r),t||i(!0)):s("No way to load scripts.")})}static fireModuleLoaded(e="Module"){"function"==typeof WasmHelper._moduleLoadedCallbacks[e]&&(WasmHelper._moduleLoadedCallbacks[e](),WasmHelper._moduleLoadedCallbacks[e]=null)}static _loadBrowserScript(e){const t=document.getElementsByTagName("head")[0],r=document.createElement("script");r.type="text/javascript",r.src=e,t.appendChild(r)}static _adjustWasmPath(e){return"undefined"!=typeof Nimiq&&Nimiq._path&&(e=`${Nimiq._path}${e}`),"string"==typeof __dirname&&-1===e.indexOf("/")&&(e=`${__dirname}/${e}`),e}static _adjustScriptPath(e){return"undefined"!=typeof Nimiq&&Nimiq._path&&(e=`${Nimiq._path}${e}`),"string"==typeof __dirname&&-1===e.indexOf("/")&&(e=`${__dirname}/${e}`),e}static get _global(){return"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:null}}WasmHelper._moduleLoadedCallbacks={},Class.register(WasmHelper);class GenesisConfig{}Class.register(GenesisConfig);class ArrayUtils{static randomElement(e){return e[Math.floor(Math.random()*e.length)]}static subarray(e,t,r){function i(e,t,r){return e<t?t:e>r?r:e}void 0===t&&(t=0),void 0===r&&(r=e.byteLength),t=i(t,0,e.byteLength);let s=(r=i(r,0,e.byteLength))-t;return s<0&&(s=0),new Uint8Array(e.buffer,e.byteOffset+t,s)}static*k_combinations(e,t){const r=e.length;if(t>r)return;const i=Array.from(new Array(t),(e,t)=>t);yield i.map(t=>e[t]);const s=Array.from(new Array(t),(e,r)=>t-r-1);for(;;){let n=t-1,a=!1;for(n of s)if(i[n]!==n+r-t){a=!0;break}if(!a)return;i[n]+=1;for(const e of Array.from(new Array(t-n-1),(e,t)=>n+t+1))i[e]=i[e-1]+1;yield i.map(t=>e[t])}}}Class.register(ArrayUtils);class Assert{static that(e,t="Assertion failed"){if(!e)throw new Error(t)}}Class.register(Assert);class MerkleTree{static computeRoot(e,t=MerkleTree._hash){return MerkleTree._computeRoot(e,t)}static _computeRoot(e,t){const r=e.length;if(0===r)return Hash.light(new Uint8Array(0));if(1===r)return t(e[0]);const i=Math.round(r/2),s=e.slice(0,i),n=e.slice(i),a=MerkleTree._computeRoot(s,t),o=MerkleTree._computeRoot(n,t);return Hash.light(BufferUtils.concatTypedArrays(a.serialize(),o.serialize()))}static _hash(e){if(e instanceof Hash)return e;if("function"==typeof e.hash)return e.hash();if("function"==typeof e.serialize)return Hash.light(e.serialize());if(e instanceof Uint8Array)return Hash.light(e);throw new Error("MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method")}}Class.register(MerkleTree);class MerklePath{constructor(e){if(!Array.isArray(e)||!NumberUtils.isUint8(e.length)||e.some(e=>!(e instanceof MerklePathNode)))throw new Error("Malformed nodes");this._nodes=e}static compute(e,t,r=MerkleTree._hash){const i=r(t),s=[];return MerklePath._compute(e,i,s,r),new MerklePath(s)}static _compute(e,t,r,i){const s=e.length;let n;if(0===s)return{containsLeaf:!1,inner:n=Hash.light(new Uint8Array(0))};if(1===s)return{containsLeaf:(n=i(e[0])).equals(t),inner:n};const a=Math.round(s/2),o=e.slice(0,a),l=e.slice(a),{containsLeaf:c,inner:h}=MerklePath._compute(o,t,r,i),{containsLeaf:u,inner:d}=MerklePath._compute(l,t,r,i);return n=Hash.light(BufferUtils.concatTypedArrays(h.serialize(),d.serialize())),c?(r.push(new MerklePathNode(d,!1)),{containsLeaf:!0,inner:n}):u?(r.push(new MerklePathNode(h,!0)),{containsLeaf:!0,inner:n}):{containsLeaf:!1,inner:n}}computeRoot(e,t=MerkleTree._hash){let r=t(e);for(const e of this._nodes){const t=e.left,i=e.hash,s=new SerialBuffer(2*i.serializedSize);t&&i.serialize(s),r.serialize(s),t||i.serialize(s),r=Hash.light(s)}return r}static _compress(e){const t=e.length,r=Math.ceil(t/8),i=new Uint8Array(r);for(let r=0;r<t;r++)e[r].left&&(i[Math.floor(r/8)]|=128>>>r%8);return i}static unserialize(e){const t=e.readUint8(),r=Math.ceil(t/8),i=e.read(r),s=[];for(let r=0;r<t;r++){const t=0!=(i[Math.floor(r/8)]&128>>>r%8),n=Hash.unserialize(e);s.push(new MerklePathNode(n,t))}return new MerklePath(s)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._nodes.length),e.write(MerklePath._compress(this._nodes));for(const t of this._nodes)t.hash.serialize(e);return e}get serializedSize(){return 1+Math.ceil(this._nodes.length/8)+this._nodes.reduce((e,t)=>e+t.hash.serializedSize,0)}equals(e){return e instanceof MerklePath&&this._nodes.length===e._nodes.length&&this._nodes.every((t,r)=>t.equals(e._nodes[r]))}get nodes(){return this._nodes}}Class.register(MerklePath);class MerklePathNode{constructor(e,t){this._hash=e,this._left=t}get hash(){return this._hash}get left(){return this._left}equals(e){return e instanceof MerklePathNode&&this._hash.equals(e.hash)&&this._left===e.left}}Class.register(MerklePathNode);class Policy{static coinsToLunas(e){return Math.round(e*Policy.LUNAS_PER_COIN)}static lunasToCoins(e){return e/Policy.LUNAS_PER_COIN}static coinsToSatoshis(e){return Policy.coinsToLunas(e)}static satoshisToCoins(e){return Policy.lunasToCoins(e)}static get SATOSHIS_PER_COIN(){return Policy.LUNAS_PER_COIN}static supplyAfter(e){let t=Math.floor(e/Policy._supplyCacheInterval)*Policy._supplyCacheInterval;const r=(t=Math.max(0,Math.min(t,Policy._supplyCacheMax)))/Policy._supplyCacheInterval,i=Math.floor(e/Policy._supplyCacheInterval);let s=0===t?Policy.INITIAL_SUPPLY:Policy._supplyCache.get(t);for(let e=r;e<i;++e){t=e*Policy._supplyCacheInterval;const r=(e+1)*Policy._supplyCacheInterval-1;s=Policy._supplyAfter(s,r,t),Policy._supplyCache.set(r+1,s),Policy._supplyCacheMax=r+1}return Policy._supplyAfter(s,e,i*Policy._supplyCacheInterval)}static _supplyAfter(e,t,r=0){let i=e;for(let e=r;e<=t;++e)i+=Policy._blockRewardAt(i,e);return i}static blockRewardAt(e){const t=Policy.supplyAfter(e-1);return Policy._blockRewardAt(t,e)}static _blockRewardAt(e,t){if(t<=0)return 0;const r=Policy.TOTAL_SUPPLY-e;return t>=Policy.EMISSION_TAIL_START&&r>=Policy.EMISSION_TAIL_REWARD?Policy.EMISSION_TAIL_REWARD:(r-r%Policy.EMISSION_SPEED)/Policy.EMISSION_SPEED}}Policy.BLOCK_TIME=60,Policy.BLOCK_SIZE_MAX=1e5,Policy.BLOCK_TARGET_MAX=new BigNumber(2).pow(240),Policy.DIFFICULTY_BLOCK_WINDOW=120,Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR=2,Policy.TRANSACTION_VALIDITY_WINDOW=120,Policy.LUNAS_PER_COIN=1e5,Policy.TOTAL_SUPPLY=21e14,Policy.INITIAL_SUPPLY=252e12,Policy.EMISSION_SPEED=Math.pow(2,22),Policy.EMISSION_TAIL_START=48692960,Policy.EMISSION_TAIL_REWARD=4e3,Policy.M=240,Policy.K=120,Policy.DELTA=.15,Policy.NUM_BLOCKS_VERIFICATION=250,Policy.NUM_SNAPSHOTS_MAX=20,Policy._supplyCache=new Map,Policy._supplyCacheMax=0,Policy._supplyCacheInterval=5e3,Class.register(Policy);class Serializable{equals(e){return e instanceof Serializable&&BufferUtils.equals(this.serialize(),e.serialize())}compare(e){return BufferUtils.compare(this.serialize(),e.serialize())}hashCode(){return this.toBase64()}serialize(e){}toString(){return this.toBase64()}toBase64(){return BufferUtils.toBase64(this.serialize())}toHex(){return BufferUtils.toHex(this.serialize())}}Class.register(Serializable);class Hash extends Serializable{constructor(e,t=Hash.Algorithm.BLAKE2B){if(null===e)e=new Uint8Array(Hash.getSize(t));else{if(!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==Hash.getSize(t))throw new Error("Primitive: Invalid length")}super(),this._obj=e,this._algorithm=t}static light(e){return Hash.blake2b(e)}static blake2b(e){return new Hash(Hash.computeBlake2b(e),Hash.Algorithm.BLAKE2B)}static hard(e){return Hash.argon2d(e)}static async argon2d(e){return new Hash(await(await CryptoWorker.getInstanceAsync()).computeArgon2d(e),Hash.Algorithm.ARGON2D)}static sha256(e){return new Hash(Hash.computeSha256(e),Hash.Algorithm.SHA256)}static sha512(e){return new Hash(Hash.computeSha512(e),Hash.Algorithm.SHA512)}static compute(e,t){switch(t){case Hash.Algorithm.BLAKE2B:return Hash.blake2b(e);case Hash.Algorithm.SHA256:return Hash.sha256(e);default:throw new Error("Invalid hash algorithm")}}static unserialize(e,t=Hash.Algorithm.BLAKE2B){return new Hash(e.read(Hash.getSize(t)),t)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(this._obj),e}subarray(e,t){return this._obj.subarray(e,t)}get serializedSize(){return Hash.SIZE.get(this._algorithm)}get array(){return this._obj}get algorithm(){return this._algorithm}equals(e){return e instanceof Hash&&e._algorithm===this._algorithm&&super.equals(e)}static fromBase64(e){return new Hash(BufferUtils.fromBase64(e))}static fromHex(e){return new Hash(BufferUtils.fromHex(e))}static fromString(e){try{return Hash.fromHex(e)}catch(e){}try{return Hash.fromBase64(e)}catch(e){}throw new Error("Invalid hash format")}static isHash(e){return e instanceof Hash}static getSize(e){const t=Hash.SIZE.get(e);if("number"!=typeof t)throw new Error("Invalid hash algorithm");return t}static computeBlake2b(e){if(PlatformUtils.isNodeJs()){const t=new Uint8Array(Hash.getSize(Hash.Algorithm.BLAKE2B));return NodeNative.node_blake2(t,new Uint8Array(e)),t}{let t;try{t=Module.stackSave();const r=Hash.getSize(Hash.Algorithm.BLAKE2B),i=Module.stackAlloc(r),s=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e);const n=Module._nimiq_blake2(i,s,e.length);if(0!==n)throw n;const a=new Uint8Array(r);return a.set(new Uint8Array(Module.HEAPU8.buffer,i,r)),a}catch(e){throw Log.w(Hash,e),e}finally{void 0!==t&&Module.stackRestore(t)}}}static computeSha256(e){if(PlatformUtils.isNodeJs()){const t=new Uint8Array(Hash.getSize(Hash.Algorithm.SHA256));return NodeNative.node_sha256(t,new Uint8Array(e)),t}{let t;try{t=Module.stackSave();const r=Hash.getSize(Hash.Algorithm.SHA256),i=Module.stackAlloc(r),s=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e),Module._nimiq_sha256(i,s,e.length);const n=new Uint8Array(r);return n.set(new Uint8Array(Module.HEAPU8.buffer,i,r)),n}catch(e){throw Log.w(Hash,e),e}finally{void 0!==t&&Module.stackRestore(t)}}}static computeSha512(e){if(PlatformUtils.isNodeJs()){const t=new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));return NodeNative.node_sha512(t,new Uint8Array(e)),t}{let t;try{t=Module.stackSave();const r=Hash.getSize(Hash.Algorithm.SHA512),i=Module.stackAlloc(r),s=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e),Module._nimiq_sha512(i,s,e.length);const n=new Uint8Array(r);return n.set(new Uint8Array(Module.HEAPU8.buffer,i,r)),n}catch(e){throw Log.w(Hash,e),e}finally{void 0!==t&&Module.stackRestore(t)}}}}Hash.Algorithm={BLAKE2B:1,ARGON2D:2,SHA256:3,SHA512:4},Hash.SIZE=new Map,Hash.SIZE.set(Hash.Algorithm.BLAKE2B,32),Hash.SIZE.set(Hash.Algorithm.ARGON2D,32),Hash.SIZE.set(Hash.Algorithm.SHA256,32),Hash.SIZE.set(Hash.Algorithm.SHA512,64),Hash.NULL=new Hash(new Uint8Array(32)),Class.register(Hash);class PublicKey extends Serializable{static copy(e){return e?new PublicKey(new Uint8Array(e._obj)):e}constructor(e){if(super(),!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==PublicKey.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static derive(e){return new PublicKey(PublicKey._publicKeyDerive(e._obj))}static sum(e){return(e=e.slice()).sort((e,t)=>e.compare(t)),PublicKey._delinearizeAndAggregatePublicKeys(e)}static unserialize(e){return new PublicKey(e.read(PublicKey.SIZE))}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(this._obj),e}get serializedSize(){return PublicKey.SIZE}equals(e){return e instanceof PublicKey&&super.equals(e)}hash(){return Hash.light(this.serialize())}compare(e){return BufferUtils.compare(this._obj,e._obj)}toAddress(){return Address.fromHash(this.hash())}toPeerId(){return new PeerId(this.hash().subarray(0,16))}static _delinearizeAndAggregatePublicKeys(e){const t=e.map(e=>e.serialize()),r=PublicKey._publicKeysHash(t),i=PublicKey._publicKeysDelinearizeAndAggregate(t,r);return new PublicKey(i)}static _publicKeyDerive(e){if(e.byteLength!==PrivateKey.SIZE)throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const t=new Uint8Array(PublicKey.SIZE);return NodeNative.node_ed25519_public_key_derive(t,new Uint8Array(e)),t}{let t;try{t=Module.stackSave();const r=Module.stackAlloc(PublicKey.SIZE),i=new Uint8Array(Module.HEAP8.buffer,r,PrivateKey.SIZE);i.set(e);const s=Module.stackAlloc(e.length),n=new Uint8Array(Module.HEAP8.buffer,s,PrivateKey.SIZE);n.set(e),Module._ed25519_public_key_derive(r,s),n.fill(0);const a=new Uint8Array(PublicKey.SIZE);return a.set(i),a}catch(e){throw Log.w(PublicKey,e),e}finally{void 0!==t&&Module.stackRestore(t)}}}static _publicKeysHash(e){if(e.some(e=>e.byteLength!==PublicKey.SIZE))throw Error("Wrong buffer size.");const t=new Uint8Array(e.length*PublicKey.SIZE);for(let r=0;r<e.length;++r)t.set(e[r],r*PublicKey.SIZE);if(PlatformUtils.isNodeJs()){const r=new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));return NodeNative.node_ed25519_hash_public_keys(r,t,e.length),r}{let r;try{r=Module.stackSave();const i=Hash.getSize(Hash.Algorithm.SHA512),s=Module.stackAlloc(i),n=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,n,t.length).set(t),Module._ed25519_hash_public_keys(s,n,e.length);const a=new Uint8Array(i);return a.set(new Uint8Array(Module.HEAPU8.buffer,s,i)),a}catch(e){throw Log.w(PublicKey,e),e}finally{void 0!==r&&Module.stackRestore(r)}}}static _publicKeyDelinearize(e,t){if(e.byteLength!==PublicKey.SIZE||t.byteLength!==Hash.getSize(Hash.Algorithm.SHA512))throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const r=new Uint8Array(PublicKey.SIZE);return NodeNative.node_ed25519_delinearize_public_key(r,new Uint8Array(t),new Uint8Array(e)),r}{let r;try{r=Module.stackSave();const i=Module.stackAlloc(PublicKey.SIZE),s=Module.stackAlloc(e.length),n=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e),new Uint8Array(Module.HEAPU8.buffer,n,t.length).set(t),Module._ed25519_delinearize_public_key(i,n,s);const a=new Uint8Array(PublicKey.SIZE);return a.set(new Uint8Array(Module.HEAPU8.buffer,i,PublicKey.SIZE)),a}catch(e){throw Log.w(PublicKey,e),e}finally{void 0!==r&&Module.stackRestore(r)}}}static _publicKeysDelinearizeAndAggregate(e,t){if(e.some(e=>e.byteLength!==PublicKey.SIZE)||t.byteLength!==Hash.getSize(Hash.Algorithm.SHA512))throw Error("Wrong buffer size.");const r=new Uint8Array(e.length*PublicKey.SIZE);for(let t=0;t<e.length;++t)r.set(e[t],t*PublicKey.SIZE);if(PlatformUtils.isNodeJs()){const i=new Uint8Array(PublicKey.SIZE);return NodeNative.node_ed25519_aggregate_delinearized_public_keys(i,new Uint8Array(t),r,e.length),i}{let i;try{i=Module.stackSave();const s=Module.stackAlloc(PublicKey.SIZE),n=Module.stackAlloc(r.length),a=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,n,r.length).set(r),new Uint8Array(Module.HEAPU8.buffer,a,t.length).set(t),Module._ed25519_aggregate_delinearized_public_keys(s,a,n,e.length);const o=new Uint8Array(PublicKey.SIZE);return o.set(new Uint8Array(Module.HEAPU8.buffer,s,PublicKey.SIZE)),o}catch(e){throw Log.w(PublicKey,e),e}finally{void 0!==i&&Module.stackRestore(i)}}}}PublicKey.SIZE=32,Class.register(PublicKey);class Signature extends Serializable{static copy(e){if(!e)return e;const t=new Uint8Array(e._obj);return new Signature(t)}constructor(e){if(super(),!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==Signature.SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static create(e,t,r){return new Signature(Signature._signatureCreate(e._obj,t._obj,r))}static fromPartialSignatures(e,t){const r=Signature._combinePartialSignatures(e.serialize(),t.map(e=>e.serialize()));return new Signature(r)}static unserialize(e){return new Signature(e.read(Signature.SIZE))}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(this._obj),e}get serializedSize(){return Signature.SIZE}verify(e,t){return Signature._signatureVerify(e._obj,t,this._obj)}equals(e){return e instanceof Signature&&super.equals(e)}static _combinePartialSignatures(e,t){const r=Signature._aggregatePartialSignatures(t);return BufferUtils.concatTypedArrays(e,r)}static _aggregatePartialSignatures(e){return e.reduce((e,t)=>Signature._scalarsAdd(e,t))}static _scalarsAdd(e,t){if(e.byteLength!==PartialSignature.SIZE||t.byteLength!==PartialSignature.SIZE)throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const r=new Uint8Array(PartialSignature.SIZE);return NodeNative.node_ed25519_add_scalars(r,new Uint8Array(e),new Uint8Array(t)),r}{let r;try{r=Module.stackSave();const i=Module.stackAlloc(PartialSignature.SIZE),s=Module.stackAlloc(e.length),n=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e),new Uint8Array(Module.HEAPU8.buffer,n,t.length).set(t),Module._ed25519_add_scalars(i,s,n);const a=new Uint8Array(PartialSignature.SIZE);return a.set(new Uint8Array(Module.HEAPU8.buffer,i,PartialSignature.SIZE)),a}catch(e){throw Log.w(Signature,e),e}finally{void 0!==r&&Module.stackRestore(r)}}}static _signatureCreate(e,t,r){if(t.byteLength!==PublicKey.SIZE||e.byteLength!==PrivateKey.SIZE)throw Error("Wrong buffer size.");if(PlatformUtils.isNodeJs()){const i=new Uint8Array(Signature.SIZE);return NodeNative.node_ed25519_sign(i,new Uint8Array(r),new Uint8Array(t),new Uint8Array(e)),i}{let i;try{i=Module.stackSave();const s=Module.stackAlloc(Signature.SIZE),n=new Uint8Array(Module.HEAP8.buffer,s,Signature.SIZE),a=Module.stackAlloc(r.length);new Uint8Array(Module.HEAP8.buffer,a,r.length).set(r);const o=Module.stackAlloc(t.length);new Uint8Array(Module.HEAP8.buffer,o,t.length).set(t);const l=Module.stackAlloc(e.length),c=new Uint8Array(Module.HEAP8.buffer,l,e.length);c.set(e),Module._ed25519_sign(s,a,r.byteLength,o,l),c.fill(0);const h=new Uint8Array(Signature.SIZE);return h.set(n),h}catch(e){throw Log.w(Signature,e),e}finally{void 0!==i&&Module.stackRestore(i)}}}static _signatureVerify(e,t,r){if(PlatformUtils.isNodeJs())return!!NodeNative.node_ed25519_verify(new Uint8Array(r),new Uint8Array(t),new Uint8Array(e));{let i;try{i=Module.stackSave();const s=Module.stackAlloc(e.length);new Uint8Array(Module.HEAP8.buffer,s,e.length).set(e);const n=Module.stackAlloc(t.length);new Uint8Array(Module.HEAP8.buffer,n,t.length).set(t);const a=Module.stackAlloc(r.length);return new Uint8Array(Module.HEAP8.buffer,a,r.length).set(r),!!Module._ed25519_verify(a,n,t.byteLength,s)}catch(e){throw Log.w(Signature,e),e}finally{void 0!==i&&Module.stackRestore(i)}}}}Signature.SIZE=64,Class.register(Signature);class Address extends Serializable{static copy(e){if(!e)return e;const t=new Uint8Array(e._obj);return new Address(t)}static fromHash(e){return new Address(e.subarray(0,Address.SERIALIZED_SIZE))}constructor(e){if(super(),!(e instanceof Uint8Array))throw new Error("Primitive: Invalid type");if(e.length!==Address.SERIALIZED_SIZE)throw new Error("Primitive: Invalid length");this._obj=e}static unserialize(e){return new Address(e.read(Address.SERIALIZED_SIZE))}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(this._obj),e}subarray(e,t){return this._obj.subarray(e,t)}get serializedSize(){return Address.SERIALIZED_SIZE}equals(e){return e instanceof Address&&super.equals(e)}static fromString(e){try{return Address.fromUserFriendlyAddress(e)}catch(e){}try{return Address.fromHex(e)}catch(e){}try{return Address.fromBase64(e)}catch(e){}throw new Error("Invalid address format")}static fromBase64(e){return new Address(BufferUtils.fromBase64(e))}static fromHex(e){return new Address(BufferUtils.fromHex(e))}static fromUserFriendlyAddress(e){if((e=e.replace(/ /g,"")).substr(0,2).toUpperCase()!==Address.CCODE)throw new Error("Invalid Address: Wrong country code");if(36!==e.length)throw new Error("Invalid Address: Should be 36 chars (ignoring spaces)");if(1!==Address._ibanCheck(e.substr(4)+e.substr(0,4)))throw new Error("Invalid Address: Checksum invalid");return new Address(BufferUtils.fromBase32(e.substr(4)))}static _ibanCheck(e){const t=e.split("").map(e=>{const t=e.toUpperCase().charCodeAt(0);return t>=48&&t<=57?e:(t-55).toString()}).join("");let r="";for(let e=0;e<Math.ceil(t.length/6);e++)r=(parseInt(r+t.substr(6*e,6))%97).toString();return parseInt(r)}toUserFriendlyAddress(e=!0){const t=BufferUtils.toBase32(this.serialize()),r=("00"+(98-Address._ibanCheck(t+Address.CCODE+"00"))).slice(-2);let i=Address.CCODE+r+t;return e&&(i=i.replace(/.{4}/g,"$& ").trim()),i}}Address.CCODE="NQ",Address.SERIALIZED_SIZE=20,Address.HEX_SIZE=40,Address.NULL=new Address(new Uint8Array(Address.SERIALIZED_SIZE)),Address.CONTRACT_CREATION=new Address(new Uint8Array(Address.SERIALIZED_SIZE)),Class.register(Address);class Account{constructor(e,t){if(!NumberUtils.isUint8(e))throw new Error("Malformed type");if(!NumberUtils.isUint64(t))throw new Error("Malformed balance");this._type=e,this._balance=t}static unserialize(e){const t=e.readUint8();if(e.readPos--,!Account.TYPE_MAP.has(t))throw new Error("Unknown account type");return Account.TYPE_MAP.get(t).unserialize(e)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._type),e.writeUint64(this._balance),e}get serializedSize(){return 9}equals(e){return BufferUtils.equals(this.serialize(),e.serialize())}toString(){return`Account{type=${this._type}, balance=${this._balance.toString()}`}get balance(){return this._balance}get type(){return this._type}withBalance(e){throw new Error("Not yet implemented.")}withOutgoingTransaction(e,t,r,i=!1){if(i){if(t<e.validityStartHeight||t>=e.validityStartHeight+Policy.TRANSACTION_VALIDITY_WINDOW)throw new Error("Validity Error!");return this.withBalance(this._balance+e.value+e.fee)}{const i=this._balance-e.value-e.fee;if(i<0)throw new Error("Balance Error!");if(t<e.validityStartHeight||t>=e.validityStartHeight+Policy.TRANSACTION_VALIDITY_WINDOW)throw new Error("Validity Error!");if(r.containsTransaction(e))throw new Error("Double Transaction Error!");return this.withBalance(i)}}withIncomingTransaction(e,t,r=!1){if(r){const t=this._balance-e.value;if(t<0)throw new Error("Balance Error!");return this.withBalance(t)}return this.withBalance(this._balance+e.value)}withContractCommand(e,t,r=!1){throw new Error("Not yet implemented")}isInitial(){return this===Account.INITIAL}isToBePruned(){return 0===this._balance&&!this.isInitial()}}Account.Type={BASIC:0,VESTING:1,HTLC:2},Account.TYPE_MAP=new Map,Class.register(Account);class PrunedAccount{constructor(e,t){if(!(e instanceof Address))throw new Error("Malformed address");this._address=e,this._account=t}static unserialize(e){return new PrunedAccount(Address.unserialize(e),Account.unserialize(e))}compare(e){return this._address.compare(e._address)}get address(){return this._address}get account(){return this._account}serialize(e){return e=e||new SerialBuffer(this.serializedSize),this._address.serialize(e),this._account.serialize(e),this}get serializedSize(){return this._address.serializedSize+this._account.serializedSize}hashCode(){return this._address.hashCode()}}Class.register(PrunedAccount);class BasicAccount extends Account{static copy(e){return e?new BasicAccount(e._balance):e}constructor(e=0){super(Account.Type.BASIC,e)}static unserialize(e){if(e.readUint8()!==Account.Type.BASIC)throw new Error("Invalid account type");const t=e.readUint64();return new BasicAccount(t)}equals(e){return e instanceof BasicAccount&&this._type===e._type&&this._balance===e._balance}toString(){return`BasicAccount{balance=${this._balance}}`}static verifyOutgoingTransaction(e){return SignatureProof.verifyTransaction(e)}static verifyIncomingTransaction(e){return!(e.data.byteLength>64)}withBalance(e){return new BasicAccount(e)}withIncomingTransaction(e,t,r=!1){if(!r){if(e.hasFlag(Transaction.Flag.CONTRACT_CREATION)!==(e.recipientType!==this._type))throw new Error("Data Error!")}return super.withIncomingTransaction(e,t,r)}withContractCommand(e,t,r=!1){return!r&&e.recipientType!==this._type&&e.hasFlag(Transaction.Flag.CONTRACT_CREATION)?Account.TYPE_MAP.get(e.recipientType).create(this._balance,t,e):this}isInitial(){return 0===this._balance}}Account.INITIAL=new BasicAccount(0),Account.TYPE_MAP.set(Account.Type.BASIC,BasicAccount),Class.register(BasicAccount);class Contract extends Account{constructor(e,t){super(e,t)}static verifyIncomingTransaction(e){return!!e.recipient.equals(e.getContractCreationAddress())}withIncomingTransaction(e,t,r=!1){if(!r&&e.hasFlag(Transaction.Flag.CONTRACT_CREATION))throw new Error("Data error");return super.withIncomingTransaction(e,t,r)}withContractCommand(e,t,r=!1){return r&&e.hasFlag(Transaction.Flag.CONTRACT_CREATION)?new BasicAccount(this.balance):this}}Class.register(Contract);class HashedTimeLockedContract extends Contract{constructor(e=0,t=Address.NULL,r=Address.NULL,i=Hash.NULL,s=1,n=0,a=e){if(super(Account.Type.HTLC,e),!(t instanceof Address))throw new Error("Malformed address");if(!(r instanceof Address))throw new Error("Malformed address");if(!(i instanceof Hash))throw new Error("Malformed address");if(!NumberUtils.isUint8(s)||0===s)throw new Error("Malformed hashCount");if(!NumberUtils.isUint32(n))throw new Error("Malformed timeout");if(!NumberUtils.isUint64(a))throw new Error("Malformed totalAmount");this._sender=t,this._recipient=r,this._hashRoot=i,this._hashCount=s,this._timeout=n,this._totalAmount=a}static create(e,t,r){const i=new SerialBuffer(r.data),s=Address.unserialize(i),n=Address.unserialize(i),a=i.readUint8(),o=Hash.unserialize(i,a),l=i.readUint8(),c=i.readUint32();return new HashedTimeLockedContract(e,s,n,o,l,c)}static unserialize(e){if(e.readUint8()!==Account.Type.HTLC)throw new Error("Invalid account type");const t=e.readUint64(),r=Address.unserialize(e),i=Address.unserialize(e),s=e.readUint8(),n=Hash.unserialize(e,s),a=e.readUint8(),o=e.readUint32(),l=e.readUint64();return new HashedTimeLockedContract(t,r,i,n,a,o,l)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),super.serialize(e),this._sender.serialize(e),this._recipient.serialize(e),e.writeUint8(this._hashRoot.algorithm),this._hashRoot.serialize(e),e.writeUint8(this._hashCount),e.writeUint32(this._timeout),e.writeUint64(this._totalAmount),e}get serializedSize(){return super.serializedSize+this._sender.serializedSize+this._recipient.serializedSize+1+this._hashRoot.serializedSize+1+4+8}get sender(){return this._sender}get recipient(){return this._recipient}get hashRoot(){return this._hashRoot}get hashCount(){return this._hashCount}get timeout(){return this._timeout}get totalAmount(){return this._totalAmount}toString(){return`HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(!1)}, recipient=${this._sender.toUserFriendlyAddress(!1)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`}equals(e){return e instanceof HashedTimeLockedContract&&this._type===e._type&&this._balance===e._balance&&this._sender.equals(e._sender)&&this._recipient.equals(e._recipient)&&this._hashRoot.equals(e._hashRoot)&&this._hashCount===e._hashCount&&this._timeout===e._timeout&&this._totalAmount===e._totalAmount}static verifyOutgoingTransaction(e){try{const t=new SerialBuffer(e.proof);switch(t.readUint8()){case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER:{const r=t.readUint8(),i=t.readUint8(),s=Hash.unserialize(t,r);let n=Hash.unserialize(t,r);for(let e=0;e<i;++e)n=Hash.compute(n.array,r);if(!s.equals(n))return!1;if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;break}case HashedTimeLockedContract.ProofType.EARLY_RESOLVE:if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;break;case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;break;default:return!1}return t.readPos===t.byteLength}catch(e){return!1}}static verifyIncomingTransaction(e){try{const t=new SerialBuffer(e.data);Address.unserialize(t),Address.unserialize(t);const r=t.readUint8();return Hash.unserialize(t,r),t.readUint8(),t.readUint32(),r!==Hash.Algorithm.ARGON2D&&(t.readPos===t.byteLength&&Contract.verifyIncomingTransaction(e))}catch(e){return!1}}withBalance(e){return new HashedTimeLockedContract(e,this._sender,this._recipient,this._hashRoot,this._hashCount,this._timeout,this._totalAmount)}withOutgoingTransaction(e,t,r,i=!1){const s=new SerialBuffer(e.proof);let n=0;switch(s.readUint8()){case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER:{if(this._timeout<t)throw new Error("Proof Error!");const e=s.readUint8(),r=s.readUint8();if(!Hash.unserialize(s,e).equals(this._hashRoot))throw new Error("Proof Error!");if(Hash.unserialize(s,e),!SignatureProof.unserialize(s).isSignedBy(this._recipient))throw new Error("Proof Error!");n=Math.max(0,Math.floor((1-r/this._hashCount)*this._totalAmount));break}case HashedTimeLockedContract.ProofType.EARLY_RESOLVE:if(!SignatureProof.unserialize(s).isSignedBy(this._recipient))throw new Error("Proof Error!");if(!SignatureProof.unserialize(s).isSignedBy(this._sender))throw new Error("Proof Error!");break;case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:if(this._timeout>=t)throw new Error("Proof Error!");if(!SignatureProof.unserialize(s).isSignedBy(this._sender))throw new Error("Proof Error!");break;default:throw new Error("Proof Error!")}if(!i){if(this._balance-e.value-e.fee<n)throw new Error("Balance Error!")}return super.withOutgoingTransaction(e,t,r,i)}withIncomingTransaction(e,t,r=!1){throw new Error("Illegal incoming transaction")}}HashedTimeLockedContract.ProofType={REGULAR_TRANSFER:1,EARLY_RESOLVE:2,TIMEOUT_RESOLVE:3},Account.TYPE_MAP.set(Account.Type.HTLC,HashedTimeLockedContract),Class.register(HashedTimeLockedContract);class VestingContract extends Contract{constructor(e=0,t=Address.NULL,r=0,i=0,s=e,n=e){if(super(Account.Type.VESTING,e),!(t instanceof Address))throw new Error("Malformed address");if(!NumberUtils.isUint32(r))throw new Error("Malformed vestingStart");if(!NumberUtils.isUint32(i))throw new Error("Malformed vestingStepBlocks");if(!NumberUtils.isUint64(s))throw new Error("Malformed vestingStepAmount");if(!NumberUtils.isUint64(n))throw new Error("Malformed lowerCap");this._owner=t,this._vestingStart=r,this._vestingStepBlocks=i,this._vestingStepAmount=s,this._vestingTotalAmount=n}static create(e,t,r){let i,s,n,a;const o=new SerialBuffer(r.data),l=Address.unserialize(o);switch(a=r.value,r.data.length){case Address.SERIALIZED_SIZE+4:i=0,s=o.readUint32(),n=a;break;case Address.SERIALIZED_SIZE+16:i=o.readUint32(),s=o.readUint32(),n=o.readUint64();break;case Address.SERIALIZED_SIZE+24:i=o.readUint32(),s=o.readUint32(),n=o.readUint64(),a=o.readUint64();break;default:throw new Error("Invalid transaction data")}return new VestingContract(e,l,i,s,n,a)}static unserialize(e){if(e.readUint8()!==Account.Type.VESTING)throw new Error("Invalid account type");const t=e.readUint64(),r=Address.unserialize(e),i=e.readUint32(),s=e.readUint32(),n=e.readUint64(),a=e.readUint64();return new VestingContract(t,r,i,s,n,a)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),super.serialize(e),this._owner.serialize(e),e.writeUint32(this._vestingStart),e.writeUint32(this._vestingStepBlocks),e.writeUint64(this._vestingStepAmount),e.writeUint64(this._vestingTotalAmount),e}get serializedSize(){return super.serializedSize+this._owner.serializedSize+4+4+8+8}get owner(){return this._owner}get vestingStart(){return this._vestingStart}get vestingStepBlocks(){return this._vestingStepBlocks}get vestingStepAmount(){return this._vestingStepAmount}get vestingTotalAmount(){return this._vestingTotalAmount}toString(){return`VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`}equals(e){return e instanceof VestingContract&&this._type===e._type&&this._balance===e._balance&&this._owner.equals(e._owner)&&this._vestingStart===e._vestingStart&&this._vestingStepBlocks===e._vestingStepBlocks&&this._vestingStepAmount===e._vestingStepAmount&&this._vestingTotalAmount===e._vestingTotalAmount}static verifyOutgoingTransaction(e){const t=new SerialBuffer(e.proof);return!!SignatureProof.unserialize(t).verify(null,e.serializeContent())&&t.readPos===t.byteLength}static verifyIncomingTransaction(e){switch(e.data.length){case Address.SERIALIZED_SIZE+4:case Address.SERIALIZED_SIZE+16:case Address.SERIALIZED_SIZE+24:return Contract.verifyIncomingTransaction(e);default:return!1}}withBalance(e){return new VestingContract(e,this._owner,this._vestingStart,this._vestingStepBlocks,this._vestingStepAmount,this._vestingTotalAmount)}withOutgoingTransaction(e,t,r,i=!1){if(!i){const r=this.getMinCap(t);if(this._balance-e.value-e.fee<r)throw new Error("Balance Error!");const i=new SerialBuffer(e.proof);if(!SignatureProof.unserialize(i).isSignedBy(this._owner))throw new Error("Proof Error!")}return super.withOutgoingTransaction(e,t,r,i)}withIncomingTransaction(e,t,r=!1){throw new Error("Illegal incoming transaction")}getMinCap(e){return this._vestingStepBlocks&&this._vestingStepAmount>0?Math.max(0,this._vestingTotalAmount-Math.floor((e-this._vestingStart)/this._vestingStepBlocks)*this._vestingStepAmount):0}}Account.TYPE_MAP.set(Account.Type.VESTING,VestingContract),Class.register(VestingContract);class BlockHeader{constructor(e,t,r,i,s,n,a,o,l=BlockHeader.CURRENT_VERSION){if(!NumberUtils.isUint16(l))throw"Malformed version";if(!Hash.isHash(e))throw"Malformed prevHash";if(!Hash.isHash(t))throw"Malformed interlinkHash";if(!Hash.isHash(r))throw"Malformed bodyHash";if(!Hash.isHash(i))throw"Malformed accountsHash";if(!NumberUtils.isUint32(s)||!BlockUtils.isValidCompact(s))throw"Malformed nBits";if(!NumberUtils.isUint32(n))throw"Invalid height";if(!NumberUtils.isUint32(a))throw"Malformed timestamp";if(!NumberUtils.isUint32(o))throw"Malformed nonce";this._version=l,this._prevHash=e,this._interlinkHash=t,this._bodyHash=r,this._accountsHash=i,this._nBits=s,this._height=n,this._timestamp=a,this._nonce=o}static unserialize(e){const t=e.readUint16();if(!BlockHeader.SUPPORTED_VERSIONS.includes(t))throw new Error(`Unsupported block version ${t}`);const r=Hash.unserialize(e),i=Hash.unserialize(e),s=Hash.unserialize(e),n=Hash.unserialize(e),a=e.readUint32(),o=e.readUint32(),l=e.readUint32(),c=e.readUint32();return new BlockHeader(r,i,s,n,a,o,l,c,t)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint16(this._version),this._prevHash.serialize(e),this._interlinkHash.serialize(e),this._bodyHash.serialize(e),this._accountsHash.serialize(e),e.writeUint32(this._nBits),e.writeUint32(this._height),e.writeUint32(this._timestamp),e.writeUint32(this._nonce),e}get serializedSize(){return 2+this._prevHash.serializedSize+this._interlinkHash.serializedSize+this._bodyHash.serializedSize+this._accountsHash.serializedSize+4+4+4+4}async verifyProofOfWork(e){const t=await this.pow(e);return BlockUtils.isProofOfWork(t,this.target)}isImmediateSuccessorOf(e){if(this.height!==e.height+1)return!1;if(this.timestamp<e.timestamp)return!1;const t=e.hash();return!!this.prevHash.equals(t)}hash(e){return this._hash=this._hash||Hash.light(this.serialize(e)),this._hash}async pow(e){return this._pow=this._pow||await Hash.hard(this.serialize(e)),this._pow}equals(e){return e instanceof BlockHeader&&this._prevHash.equals(e.prevHash)&&this._interlinkHash.equals(e.interlinkHash)&&this._bodyHash.equals(e.bodyHash)&&this._accountsHash.equals(e.accountsHash)&&this._nBits===e.nBits&&this._height===e.height&&this._timestamp===e.timestamp&&this._nonce===e.nonce}toString(){return"BlockHeader{"+`prevHash=${this._prevHash}, `+`interlinkHash=${this._interlinkHash}, `+`bodyHash=${this._bodyHash}, `+`accountsHash=${this._accountsHash}, `+`nBits=${this._nBits.toString(16)}, `+`height=${this._height}, `+`timestamp=${this._timestamp}, `+`nonce=${this._nonce}`+"}"}get version(){return this._version}get prevHash(){return this._prevHash}get interlinkHash(){return this._interlinkHash}get bodyHash(){return this._bodyHash}get accountsHash(){return this._accountsHash}get nBits(){return this._nBits}get target(){return BlockUtils.compactToTarget(this._nBits)}get difficulty(){return BlockUtils.compactToDifficulty(this._nBits)}get height(){return this._height}get timestamp(){return this._timestamp}get nonce(){return this._nonce}set nonce(e){this._nonce=e,this._hash=null,this._pow=null}}BlockHeader.Version={V1:1},BlockHeader.CURRENT_VERSION=BlockHeader.Version.V1,BlockHeader.SUPPORTED_VERSIONS=[BlockHeader.Version.V1],BlockHeader.SERIALIZED_SIZE=146,Class.register(BlockHeader);class BlockInterlink{static _compress(e,t){const r=e.length,i=Math.ceil(r/8),s=new Uint8Array(i);let n=t;const a=[];for(let t=0;t<r;t++){const r=e[t];r.equals(n)?s[Math.floor(t/8)]|=128>>>t%8:(a.push(r),n=r)}return{repeatBits:s,compressed:a}}constructor(e,t,r,i){if(!Array.isArray(e)||!NumberUtils.isUint8(e.length)||e.some(e=>!(e instanceof Hash)))throw new Error("Malformed hashes");if((r||i)&&(!r||!i))throw new Error("Malformed repeatBits/compressed");if(!t&&!r)throw new Error("Either prevHash or repeatBits/compressed required");r||({repeatBits:r,compressed:i}=BlockInterlink._compress(e,t)),this._hashes=e,this._repeatBits=r,this._compressed=i}static unserialize(e,t){const r=e.readUint8(),i=Math.ceil(r/8),s=e.read(i);let n=t;const a=[],o=[];for(let t=0;t<r;t++){0!=(s[Math.floor(t/8)]&128>>>t%8)||(n=Hash.unserialize(e),o.push(n)),a.push(n)}return new BlockInterlink(a,t,s,o)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._hashes.length),e.write(this._repeatBits);for(const t of this._compressed)t.serialize(e);return e}get serializedSize(){return 1+this._repeatBits.length+this._compressed.reduce((e,t)=>e+t.serializedSize,0)}equals(e){return e instanceof BlockInterlink&&this._hashes.length===e._hashes.length&&this._hashes.every((t,r)=>t.equals(e.hashes[r]))}hash(){return this._hash||(this._hash=MerkleTree.computeRoot([this._repeatBits,GenesisConfig.GENESIS_HASH,...this._compressed])),this._hash}get hashes(){return this._hashes}get length(){return this._hashes.length}}Class.register(BlockInterlink);class BlockBody{static getMetadataSize(e){return Address.SERIALIZED_SIZE+1+e.byteLength+2+2}constructor(e,t,r=new Uint8Array(0),i=[]){if(!(e instanceof Address))throw"Malformed minerAddr";if(!Array.isArray(t)||t.some(e=>!(e instanceof Transaction)))throw"Malformed transactions";if(!(r instanceof Uint8Array&&NumberUtils.isUint8(r.byteLength)))throw"Malformed extraData";this._minerAddr=e,this._extraData=r,this._transactions=t,this._prunedAccounts=i,this._hash=null}static unserialize(e){const t=Address.unserialize(e),r=e.readUint8(),i=e.read(r),s=e.readUint16(),n=new Array(s);for(let t=0;t<s;t++)n[t]=Transaction.unserialize(e);const a=e.readUint16(),o=[];for(let t=0;t<a;t++)o.push(PrunedAccount.unserialize(e));return new BlockBody(t,n,i,o)}serialize(e){e=e||new SerialBuffer(this.serializedSize),this._minerAddr.serialize(e),e.writeUint8(this._extraData.byteLength),e.write(this._extraData),e.writeUint16(this._transactions.length);for(const t of this._transactions)t.serialize(e);e.writeUint16(this._prunedAccounts.length);for(const t of this._prunedAccounts)t.serialize(e);return e}get serializedSize(){let e=this._minerAddr.serializedSize+1+this._extraData.byteLength+2+2;for(const t of this._transactions)e+=t.serializedSize;return e+=this._prunedAccounts.reduce((e,t)=>e+t.serializedSize,0)}verify(){let e=null;for(const t of this._transactions){if(e&&e.compareBlockOrder(t)>=0)return Log.w(BlockBody,"Invalid block - transactions not ordered."),!1;if(e=t,!t.verify())return Log.w(BlockBody,"Invalid block - invalid transaction"),!1}let t=null;for(const e of this._prunedAccounts){if(t&&t.compare(e)>=0)return Log.w(BlockBody,"Invalid block - pruned accounts not ordered."),!1;if(t=e,!e.account.isToBePruned())return Log.w(BlockBody,"Invalid block - invalid pruned account"),!1}return!0}getMerkleLeafs(){return[this._minerAddr,this._extraData,...this._transactions,...this.prunedAccounts]}hash(){return this._hash||(this._hash=MerkleTree.computeRoot(this.getMerkleLeafs())),this._hash}equals(e){return e instanceof BlockBody&&this._minerAddr.equals(e.minerAddr)&&BufferUtils.equals(this._extraData,e.extraData)&&this._transactions.length===e.transactions.length&&this._transactions.every((t,r)=>t.equals(e.transactions[r]))}getAddresses(){const e=[this._minerAddr];for(const t of this._transactions)e.push(t.sender,t.recipient);return e}get extraData(){return this._extraData}get minerAddr(){return this._minerAddr}get transactions(){return this._transactions}get transactionCount(){return this._transactions.length}get prunedAccounts(){return this._prunedAccounts}}Class.register(BlockBody);class BlockUtils{static compactToTarget(e){return new BigNumber(16777215&e).times(new BigNumber(2).pow(8*Math.max((e>>24)-3,0)))}static targetToCompact(e){if(!e.isFinite()||e.isNaN())throw"Invalid Target";let t=Math.max(Math.ceil(Math.log2(e.toNumber())/8),1);return e/Math.pow(2,8*(t-1))>=128&&t>=3&&t++,(t<<24)+(e/Math.pow(2,8*Math.max(t-3,0))&16777215)}static getTargetHeight(e){return Math.ceil(Math.log2(e.toNumber()))}static getTargetDepth(e){return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX)-BlockUtils.getTargetHeight(e)}static compactToDifficulty(e){return Policy.BLOCK_TARGET_MAX.div(BlockUtils.compactToTarget(e))}static difficultyToCompact(e){return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(e))}static difficultyToTarget(e){return Policy.BLOCK_TARGET_MAX.div(e)}static targetToDifficulty(e){return Policy.BLOCK_TARGET_MAX.div(e)}static hashToTarget(e){return new BigNumber(e.toHex(),16)}static realDifficulty(e){return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(e))}static getHashDepth(e){return BlockUtils.getTargetDepth(BlockUtils.hashToTarget(e))}static isProofOfWork(e,t){return new BigNumber(e.toHex(),16).lte(t)}static isValidCompact(e){return BlockUtils.isValidTarget(BlockUtils.compactToTarget(e))}static isValidTarget(e){return null!==e&&e.gte(1)&&e.lte(Policy.BLOCK_TARGET_MAX)}static getNextTarget(e,t,r){Assert.that(e.height-t.height===Policy.DIFFICULTY_BLOCK_WINDOW||e.height<=Policy.DIFFICULTY_BLOCK_WINDOW&&1===t.height,`Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);let i=e.timestamp-t.timestamp;e.height<=Policy.DIFFICULTY_BLOCK_WINDOW&&(i+=(Policy.DIFFICULTY_BLOCK_WINDOW-e.height+1)*Policy.BLOCK_TIME,r=r.plus(Policy.DIFFICULTY_BLOCK_WINDOW-e.height+1));let s=i/(Policy.DIFFICULTY_BLOCK_WINDOW*Policy.BLOCK_TIME);s=Math.max(s,1/Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR),s=Math.min(s,Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);const n=r.div(Policy.DIFFICULTY_BLOCK_WINDOW);let a=BlockUtils.difficultyToTarget(n).times(s);a=BigNumber.min(a,Policy.BLOCK_TARGET_MAX),a=BigNumber.max(a,1);const o=BlockUtils.targetToCompact(a);return BlockUtils.compactToTarget(o)}}Class.register(BlockUtils);class Block{constructor(e,t,r){if(!(e instanceof BlockHeader))throw"Malformed header";if(!(t instanceof BlockInterlink))throw"Malformed interlink";if(r&&!(r instanceof BlockBody))throw"Malformed body";this._header=e,this._interlink=t,this._body=r}static unserialize(e){const t=BlockHeader.unserialize(e),r=BlockInterlink.unserialize(e,t.prevHash);let i=void 0;return e.readUint8()&&(i=BlockBody.unserialize(e)),new Block(t,r,i)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),this._header.serialize(e),this._interlink.serialize(e),this._body?(e.writeUint8(1),this._body.serialize(e)):e.writeUint8(0),e}get serializedSize(){return this._header.serializedSize+this._interlink.serializedSize+1+(this._body?this._body.serializedSize:0)}async verify(e){if(void 0===this._valid)if(this.isLight()||this.body.transactions.length<150||!IWorker.areWorkersAsync)this._valid=await this._verify(e.now());else{const t=this.body.transactions.map(e=>e._valid),r=await CryptoWorker.getInstanceAsync(),{valid:i,pow:s,interlinkHash:n,bodyHash:a}=await r.blockVerify(this.serialize(),t,e.now(),GenesisConfig.GENESIS_HASH.serialize(),GenesisConfig.NETWORK_ID);this._valid=i,this.header._pow=Hash.unserialize(new SerialBuffer(s)),this.interlink._hash=Hash.unserialize(new SerialBuffer(n)),this.body._hash=Hash.unserialize(new SerialBuffer(a))}return this._valid}async _verify(e){return 1e3*this._header.timestamp>e+1e3*Block.TIMESTAMP_DRIFT_MAX?(Log.w(Block,"Invalid block - timestamp too far in the future"),!1):await this._header.verifyProofOfWork()?this.serializedSize>Policy.BLOCK_SIZE_MAX?(Log.w(Block,"Invalid block - max block size exceeded"),!1):!!this._verifyInterlink()&&!(this.isFull()&&!this._verifyBody()):(Log.w(Block,"Invalid block - PoW verification failed"),!1)}_verifyInterlink(){if(1===this.height&&this._header.interlinkHash.equals(new Hash(null)))return!0;const e=this._interlink.hash();return!!this._header.interlinkHash.equals(e)||(Log.w(Block,"Invalid block - interlink hash mismatch"),!1)}_verifyBody(){if(!this._body.verify())return!1;const e=this._body.hash();return!!this._header.bodyHash.equals(e)||(Log.w(Block,"Invalid block - body hash mismatch"),!1)}async isImmediateSuccessorOf(e){if(!this._header.isImmediateSuccessorOf(e.header))return!1;const t=await e.getNextInterlink(this.target,this.version);return!!this._interlink.equals(t)}async isInterlinkSuccessorOf(e){if(this._header.height<=e.header.height)return Log.v(Block,"No interlink successor - height"),!1;if(this._header.timestamp<e.header.timestamp)return Log.v(Block,"No interlink successor - timestamp"),!1;const t=e.hash();if(!GenesisConfig.GENESIS_HASH.equals(t)){const r=await e.pow(),i=BlockUtils.getTargetHeight(this.target);let s=!1,n=0;for(;n<this._interlink.length;n++)if(t.equals(this._interlink.hashes[n])){s=!0;const e=new BigNumber(2).pow(i-n);if(!BlockUtils.isProofOfWork(r,e))return Log.v(Block,"No interlink successor - invalid position in interlink"),!1}if(!s)return Log.v(Block,"No interlink successor - not in interlink"),!1}if(this._header.prevHash.equals(t)){if(this._header.height!==e.header.height+1)return Log.v(Block,"No interlink successor - immediate height"),!1;const t=(await e.getNextInterlink(this.target,this.version)).hash();if(!this._header.interlinkHash.equals(t))return Log.v(Block,"No interlink successor - immediate interlink"),!1}else{if(this._header.height===e.header.height+1)return Log.v(Block,"No interlink successor - immediate height (2)"),!1;{const t=new HashSet;if(t.addAll(this._interlink.hashes),t.removeAll(e.interlink.hashes),t.length>this._header.height-e.header.height)return Log.v(Block,"No interlink successor - too many new blocks"),!1;const r=BlockUtils.getTargetDepth(this.target)-BlockUtils.getTargetDepth(e.target);if(this._interlink.length<e.interlink.length-r)return Log.v(Block,"No interlink successor - interlink too short"),!1;let i=!1;const s=this._interlink.hashes,n=e.interlink.hashes;for(let e=1;e<n.length&&e-r<s.length;e++)if(n[e].equals(s[e-r]))i=!0;else if(i)return Log.v(Block,"No interlink successor - invalid common suffix"),!1}}return!0}async isSuccessorOf(e){return await this.isImmediateSuccessorOf(e)||await this.isInterlinkSuccessorOf(e)}async getNextInterlink(e,t=BlockHeader.CURRENT_VERSION){const r=[],i=this.hash(),s=BlockUtils.getHashDepth(await this.pow()),n=BlockUtils.getTargetDepth(e),a=Math.max(s-n+1,0);for(let e=0;e<a;e++)r.push(i);for(let e=a+(n-BlockUtils.getTargetDepth(this.target));e<this.interlink.length;e++)r.push(this.interlink.hashes[e]);return new BlockInterlink(r,i)}shallowCopy(){return new Block(this._header,this._interlink,this._body)}equals(e){return e instanceof Block&&this._header.equals(e._header)&&this._interlink.equals(e._interlink)&&(this._body?this._body.equals(e._body):!e._body)}isLight(){return!this._body}isFull(){return!!this._body}toLight(){return this.isLight()?this:new Block(this._header,this._interlink)}toFull(e){return this.isFull()?this:new Block(this._header,this._interlink,e)}get header(){return this._header}get interlink(){return this._interlink}get body(){if(this.isLight())throw"Cannot access body of light block";return this._body}get version(){return this._header.version}get prevHash(){return this._header.prevHash}get bodyHash(){return this._header.bodyHash}get accountsHash(){return this._header.accountsHash}get nBits(){return this._header.nBits}get target(){return this._header.target}get difficulty(){return this._header.difficulty}get height(){return this._header.height}get timestamp(){return this._header.timestamp}get nonce(){return this._header.nonce}get minerAddr(){return this._body.minerAddr}get transactions(){return this._body.transactions}get transactionCount(){return this._body.transactionCount}hash(e){return this._header.hash(e)}pow(e){return this._header.pow(e)}toString(){return`Block{height=${this.height},prev=${this.prevHash}}`}}Block.TIMESTAMP_DRIFT_MAX=600,Class.register(Block);class Transaction{constructor(e,t,r,i,s,n,a,o,l,c,h,u=GenesisConfig.NETWORK_ID){if(!(t instanceof Address))throw new Error("Malformed sender");if(!NumberUtils.isUint8(r))throw new Error("Malformed sender type");if(!(i instanceof Address))throw new Error("Malformed recipient");if(!NumberUtils.isUint8(s))throw new Error("Malformed recipient type");if(!NumberUtils.isUint64(n)||0===n)throw new Error("Malformed value");if(!NumberUtils.isUint64(a))throw new Error("Malformed fee");if(!NumberUtils.isUint32(o))throw new Error("Malformed validityStartHeight");if(!NumberUtils.isUint8(l)&&(l&~Transaction.Flag.ALL)>0)throw new Error("Malformed flags");if(!(c instanceof Uint8Array&&NumberUtils.isUint16(c.byteLength)))throw new Error("Malformed data");if(h&&(!(h instanceof Uint8Array)||!NumberUtils.isUint16(h.byteLength)))throw new Error("Malformed proof");if(!NumberUtils.isUint8(u))throw new Error("Malformed networkId");this._format=e,this._sender=t,this._senderType=r,this._recipient=i,this._recipientType=s,this._value=n,this._fee=a,this._networkId=u,this._validityStartHeight=o,this._flags=l,this._data=c,this._proof=h,this._recipient===Address.CONTRACT_CREATION&&(this._recipient=this.getContractCreationAddress())}static unserialize(e){const t=e.readUint8();if(e.readPos--,!Transaction.FORMAT_MAP.has(t))throw new Error("Invalid transaction type");return Transaction.FORMAT_MAP.get(t).unserialize(e)}serializeContent(e){return(e=e||new SerialBuffer(this.serializedContentSize)).writeUint16(this._data.byteLength),e.write(this._data),this._sender.serialize(e),e.writeUint8(this._senderType),this._recipient.serialize(e),e.writeUint8(this._recipientType),e.writeUint64(this._value),e.writeUint64(this._fee),e.writeUint32(this._validityStartHeight),e.writeUint8(this._networkId),e.writeUint8(this._flags),e}get serializedContentSize(){return 2+this._data.byteLength+this._sender.serializedSize+1+this._recipient.serializedSize+1+8+8+4+1+1}verify(e){return void 0===this._valid&&(this._valid=this._verify(e)),this._valid}_verify(e=GenesisConfig.NETWORK_ID){return this._networkId!==e?(Log.w(Transaction,"Transaction is not valid in this network",this),!1):this._recipient.equals(this._sender)?(Log.w(Transaction,"Sender and recipient must not match",this),!1):Account.TYPE_MAP.has(this._senderType)&&Account.TYPE_MAP.has(this._recipientType)?Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)?!!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)||(Log.w(Transaction,"Invalid for recipient",this),!1):(Log.w(Transaction,"Invalid for sender",this),!1):(Log.w(Transaction,"Invalid account type",this),!1)}get serializedSize(){throw new Error("Getter needs to be overwritten by subclasses")}serialize(e){throw new Error("Method needs to be overwritten by subclasses")}hash(){return this._hash=this._hash||Hash.light(this.serializeContent()),this._hash}compare(e){return this.fee/this.serializedSize>e.fee/e.serializedSize?-1:this.fee/this.serializedSize<e.fee/e.serializedSize?1:this.serializedSize>e.serializedSize?-1:this.serializedSize<e.serializedSize?1:this.fee>e.fee?-1:this.fee<e.fee?1:this.value>e.value?-1:this.value<e.value?1:this.compareBlockOrder(e)}compareBlockOrder(e){const t=this._recipient.compare(e._recipient);if(0!==t)return t;if(this._validityStartHeight<e._validityStartHeight)return-1;if(this._validityStartHeight>e._validityStartHeight)return 1;if(this._fee>e._fee)return-1;if(this._fee<e._fee)return 1;if(this._value>e._value)return-1;if(this._value<e._value)return 1;const r=this._sender.compare(e._sender);return 0!==r?r:this._recipientType<e._recipientType?-1:this._recipientType>e._recipientType?1:this._senderType<e._senderType?-1:this._senderType>e._senderType?1:this._flags<e._flags?-1:this._flags>e._flags?1:BufferUtils.compare(this._data,e._data)}equals(e){return e instanceof Transaction&&this._sender.equals(e._sender)&&this._senderType===e._senderType&&this._recipient.equals(e._recipient)&&this._recipientType===e._recipientType&&this._value===e._value&&this._fee===e._fee&&this._validityStartHeight===e._validityStartHeight&&this._networkId===e._networkId&&this._flags===e._flags&&BufferUtils.equals(this._data,e._data)}toString(){return"Transaction{"+`sender=${this._sender.toBase64()}, `+`recipient=${this._recipient.toBase64()}, `+`value=${this._value}, `+`fee=${this._fee}, `+`validityStartHeight=${this._validityStartHeight}, `+`networkId=${this._networkId}`+"}"}getContractCreationAddress(){const e=Transaction.unserialize(this.serialize());return e._recipient=Address.NULL,e._hash=null,Address.fromHash(e.hash())}get sender(){return this._sender}get senderType(){return this._senderType}get recipient(){return this._recipient}get recipientType(){return this._recipientType}get value(){return this._value}get fee(){return this._fee}get feePerByte(){return this._fee/this.serializedSize}get networkId(){return this._networkId}get validityStartHeight(){return this._validityStartHeight}get flags(){return this._flags}hasFlag(e){return(this._flags&e)>0}get data(){return this._data}get proof(){return this._proof}set proof(e){this._proof=e}}Transaction.Format={BASIC:0,EXTENDED:1},Transaction.Flag={NONE:0,CONTRACT_CREATION:1,ALL:1},Transaction.FORMAT_MAP=new Map,Class.register(Transaction);class SignatureProof{static verifyTransaction(e){try{const t=new SerialBuffer(e.proof),r=SignatureProof.unserialize(t);return t.readPos!==t.byteLength?(Log.w(SignatureProof,"Invalid SignatureProof - overlong"),!1):r.verify(e.sender,e.serializeContent())}catch(e){return Log.w(SignatureProof,`Failed to verify transaction: ${e.message||e}`,e),!1}}static singleSig(e,t){return new SignatureProof(e,new MerklePath([]),t)}static multiSig(e,t,r){const i=MerklePath.compute(t,e);return new SignatureProof(e,i,r)}constructor(e,t,r){if(!(e instanceof PublicKey))throw new Error("Malformed publickKey");if(!(t instanceof MerklePath))throw new Error("Malformed merklePath");if(r&&!(r instanceof Signature))throw new Error("Malformed signature");this._publicKey=e,this._merklePath=t,this._signature=r}static unserialize(e){const t=PublicKey.unserialize(e),r=MerklePath.unserialize(e),i=Signature.unserialize(e);return new SignatureProof(t,r,i)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),this._publicKey.serialize(e),this._merklePath.serialize(e),this._signature&&this._signature.serialize(e),e}get serializedSize(){return this._publicKey.serializedSize+this._merklePath.serializedSize+(this._signature?this._signature.serializedSize:0)}equals(e){return e instanceof SignatureProof&&this._publicKey.equals(e._publicKey)&&this._merklePath.equals(e._merklePath)&&(this._signature?this._signature.equals(e._signature):this._signature===e._signature)}verify(e,t){return null===e||this.isSignedBy(e)?this._signature?!!this._signature.verify(this._publicKey,t)||(Log.w(SignatureProof,"Invalid SignatureProof - signature is invalid"),!1):(Log.w(SignatureProof,"Invalid SignatureProof - signature is missing"),!1):(Log.w(SignatureProof,"Invalid SignatureProof - signer does not match sender address"),!1)}isSignedBy(e){const t=this._merklePath.computeRoot(this._publicKey);return Address.fromHash(t).equals(e)}get publicKey(){return this._publicKey}get merklePath(){return this._merklePath}get signature(){return this._signature}set signature(e){this._signature=e}}Class.register(SignatureProof);class BasicTransaction extends Transaction{constructor(e,t,r,i,s,n,a){if(!(e instanceof PublicKey))throw new Error("Malformed senderPubKey");if(void 0!==n&&!(n instanceof Signature))throw new Error("Malformed signature");const o=SignatureProof.singleSig(e,n);super(Transaction.Format.BASIC,e.toAddress(),Account.Type.BASIC,t,Account.Type.BASIC,r,i,s,Transaction.Flag.NONE,new Uint8Array(0),o.serialize(),a),this._signatureProof=o}static unserialize(e){const t=e.readUint8();Assert.that(t===Transaction.Format.BASIC);const r=PublicKey.unserialize(e),i=Address.unserialize(e),s=e.readUint64(),n=e.readUint64(),a=e.readUint32(),o=e.readUint8(),l=Signature.unserialize(e);return new BasicTransaction(r,i,s,n,a,l,o)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint8(Transaction.Format.BASIC),this.senderPubKey.serialize(e),this._recipient.serialize(e),e.writeUint64(this._value),e.writeUint64(this._fee),e.writeUint32(this._validityStartHeight),e.writeUint8(this._networkId),this.signature.serialize(e),e}get serializedSize(){return 1+this.senderPubKey.serializedSize+this._recipient.serializedSize+8+8+4+1+this.signature.serializedSize}get senderPubKey(){return this._signatureProof.publicKey}get signature(){return this._signatureProof.signature}set signature(e){this._signatureProof.signature=e,this._proof=this._signatureProof.serialize()}}Transaction.FORMAT_MAP.set(Transaction.Format.BASIC,BasicTransaction),Class.register(BasicTransaction);class ExtendedTransaction extends Transaction{constructor(e,t,r,i,s,n,a,o,l,c=new Uint8Array(0),h){super(Transaction.Format.EXTENDED,e,t,r,i,s,n,a,o,l,c,h)}static unserialize(e){const t=e.readUint8();Assert.that(t===Transaction.Format.EXTENDED);const r=e.readUint16(),i=e.read(r),s=Address.unserialize(e),n=e.readUint8(),a=Address.unserialize(e),o=e.readUint8(),l=e.readUint64(),c=e.readUint64(),h=e.readUint32(),u=e.readUint8(),d=e.readUint8(),f=e.readUint16(),g=e.read(f);return new ExtendedTransaction(s,n,a,o,l,c,h,d,i,g,u)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint8(Transaction.Format.EXTENDED),this.serializeContent(e),e.writeUint16(this._proof.byteLength),e.write(this._proof),e}get serializedSize(){return 1+this.serializedContentSize+2+this._proof.byteLength}}Transaction.FORMAT_MAP.set(Transaction.Format.EXTENDED,ExtendedTransaction),Class.register(ExtendedTransaction);
//# sourceMappingURL=worker.js.map
